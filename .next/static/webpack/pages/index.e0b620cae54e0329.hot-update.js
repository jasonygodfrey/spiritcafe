"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/app.js":
/*!**********************!*\
  !*** ./utils/app.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeThreeJS: function() { return /* binding */ initializeThreeJS; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer.js */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var simplex_noise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! simplex-noise */ \"./node_modules/simplex-noise/dist/esm/simplex-noise.js\");\n/* harmony import */ var three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader.js */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n/* harmony import */ var three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls.js */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\n\n\n\n\n\n\nfunction initializeThreeJS(mountPoint) {\n    // Initialize the noise generator\n    const noise3DFunction = (0,simplex_noise__WEBPACK_IMPORTED_MODULE_0__.createNoise3D)();\n    const mouseRadius = 0.02; // Adjust this value as needed\n    const mouseStrength = 0.005; // Adjust this value as needed, if not defined elsewhere\n    // Set up the scene, camera, and renderer\n    const scene = new three__WEBPACK_IMPORTED_MODULE_1__.Scene();\n    const camera = new three__WEBPACK_IMPORTED_MODULE_1__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    const renderer = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer({\n        alpha: true\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    //renderer.setClearColor(0x000000, 0);\n    renderer.setClearColor(0xF5F5DC, 1); // Beige color\n    mountPoint.appendChild(renderer.domElement);\n    // Initialize the Effect Composer\n    const composer = new three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_2__.EffectComposer(renderer);\n    const renderPass = new three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__.RenderPass(scene, camera);\n    composer.addPass(renderPass);\n    const bloomOptions = {\n        strength: 0.465,\n        radius: 0.3,\n        threshold: 0\n    };\n    const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_4__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(window.innerWidth, window.innerHeight), bloomOptions.strength, bloomOptions.radius, bloomOptions.threshold);\n    composer.addPass(bloomPass);\n    // Define the textureLoader here\n    const textureLoader = new three__WEBPACK_IMPORTED_MODULE_1__.TextureLoader();\n    let mouse = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(10000, 10000);\n    let raycaster = new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();\n    const cameraParallaxFactor = 0.5;\n    window.addEventListener(\"mousemove\", (e)=>{\n        mouse.x = e.clientX / window.innerWidth * 2 - 1;\n        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n        mouse.z = getAverageParticleZ();\n        raycaster.setFromCamera(mouse, camera);\n        if (!raycaster.ray) {\n            console.error(\"Raycaster ray is not initialized.\");\n            return; // Exit the function early to prevent further errors\n        }\n        let intersectPoint = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        raycaster.ray.at(1.3, intersectPoint);\n        camera.position.x += (intersectPoint.x * cameraParallaxFactor - camera.position.x) * 0.05;\n        camera.position.y += (-intersectPoint.y * cameraParallaxFactor - camera.position.y) * 0.05;\n        camera.lookAt(scene.position);\n    });\n    const controls = new three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_5__.OrbitControls(camera, renderer.domElement);\n    controls.enableRotate = false;\n    controls.enablePan = false;\n    controls.enableZoom = true;\n    // Prevent the camera from going under the axis\n    controls.minPolarAngle = 0; // Prevents the camera from going below the horizontal plane\n    controls.maxPolarAngle = Math.PI / 2; // Prevents the camera from going above the horizontal plane\n    // Define particlesGeometry in the outer scope\n    let particlesGeometry;\n    const ambientLight = new three__WEBPACK_IMPORTED_MODULE_1__.AmbientLight(0xffffff, 0.8); // soft white light\n    scene.add(ambientLight);\n    const directionalLight = new three__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(0xffffff, 0.1);\n    directionalLight.position.set(0, 1, 1); // set the direction of the light\n    scene.add(directionalLight);\n    const loader = new three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_6__.GLTFLoader();\n    loader.load(\"sushiresturantkit/scene.gltf\", function(gltf) {\n        scene.add(gltf.scene);\n        scene.position.y -= 1; // Lower the scene by 5 units\n    }, undefined, function(error) {\n        console.error(error);\n    });\n    scene.rotation.y -= Math.PI / 2;\n    textureLoader.load(\"skrillex2023logo.png\", (imageTexture)=>{\n    // ...\n    //  particlesGeometry = new THREE.BufferGeometry();\n    // ...\n    });\n    function getAverageParticleZ() {\n        if (!particlesGeometry) {\n            return 0;\n        }\n        const positions = particlesGeometry.attributes.position.array;\n        let totalZ = 0;\n        for(let i = 2; i < positions.length; i += 3){\n            totalZ += positions[i];\n        }\n        return totalZ / (positions.length / 3);\n    }\n    window.addEventListener(\"touchstart\", handleTouch);\n    window.addEventListener(\"touchmove\", handleTouch);\n    function handleTouch(e) {\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouse.x = touch.clientX / window.innerWidth * 2 - 1;\n            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;\n            mouse.z = getAverageParticleZ();\n            raycaster.setFromCamera(mouse, camera);\n            const intersectPoint = raycaster.ray.at(1.3);\n            camera.position.x += (intersectPoint.x * cameraParallaxFactor - camera.position.x) * 0.05;\n            camera.position.y += (-intersectPoint.y * cameraParallaxFactor - camera.position.y) * 0.05;\n            camera.position.y += (-intersectPoint.y * cameraParallaxFactor - camera.position.y) * 0.05 + 10; // Adjust this value as needed\n            camera.lookAt(scene.position);\n        }\n    // Add a new function to calculate the average z-coordinate of all particles\n    }\n    const scale = 4; // Adjust this value for your desired scale. E.g., 0.5 means the image will be 50% smaller\n    textureLoader.load(\"circle.png\", (imageTexture)=>{\n        const imgWidth = imageTexture.image.width * scale;\n        const imgHeight = imageTexture.image.height * scale;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = imgWidth;\n        canvas.height = imgHeight;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(imageTexture.image, 0, 0, imgWidth, imgHeight);\n        const imgData = context.getImageData(0, 0, imgWidth, imgHeight).data;\n        const resolutionFactor = 3;\n        const particleTexture = textureLoader.load(\"particles2.png\");\n        const particlesGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n        const particleVertices = [];\n        const particleColors = [];\n        const originalPositions = [];\n        const increasedBrightness = 2.25; // Place this before the loop\n        for(let y = 0; y < imgHeight; y += resolutionFactor){\n            for(let x = 0; x < imgWidth; x += resolutionFactor){\n                const index = (y * imgWidth + x) * 4;\n                const r = imgData[index];\n                const g = imgData[index + 1];\n                const b = imgData[index + 2];\n                const brightness = 0.7152 * r + 0.2126 * g + 0.0722 * b;\n                if (brightness > 128) {\n                    const xPos = (x / imgWidth - 0.5) * 2;\n                    const yPos = (y / imgHeight - 0.5) * -2;\n                    particleVertices.push(xPos, yPos, 0);\n                    originalPositions.push(xPos, yPos, 0);\n                    particleColors.push(r / 255 * increasedBrightness * 0.8, g / 255 * increasedBrightness, b / 255 * increasedBrightness);\n                }\n                particleColors.push(1, 0, 0); // Set RGB values to (1, 0, 0) for red\n            }\n        }\n        particlesGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleVertices, 3));\n        particlesGeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleColors, 3));\n        const particlesMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.PointsMaterial({\n            size: 0.02,\n            map: particleTexture,\n            vertexColors: true,\n            transparent: true,\n            opacity: 1\n        });\n        const particles = new three__WEBPACK_IMPORTED_MODULE_1__.Points(particlesGeometry, particlesMaterial);\n        //scene.add(particles);\n        const radius = 1; // Replace with the desired radius of the circle\n        const segments = 32; // Replace with the desired number of segments to approximate the circle\n        const circleTexture = textureLoader.load(\"circle4.png\");\n        const circleMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            map: circleTexture\n        });\n        const circleGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.CircleGeometry(radius, segments);\n        const circleMesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(circleGeometry, circleMaterial);\n        circleMesh.position.set(0, 0, -2);\n        circleMesh.rotation.set(0, 0, 0);\n        //scene.add(circleMesh);\n        // Then, in your animate function:\n        function animate() {\n            const positions = particlesGeometry.attributes.position.array;\n            const time = Date.now() * 0.0001; // adjust the multiplier to control the speed of the animation\n            if (!deviceOrientationActive) {\n                controls.update();\n                for(let i = 0; i < positions.length; i += 3){\n                    let particlePos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(positions[i], positions[i + 1], positions[i + 2]);\n                    let originalPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(originalPositions[i], originalPositions[i + 1], originalPositions[i + 2]);\n                    // Calculate the distance between the particle and the mouse\n                    let distanceToMouse = particlePos.distanceTo(mouse);\n                    // If the distance is less than the mouseRadius, move the particle towards the mouse\n                    if (distanceToMouse < mouseRadius) {\n                        particlePos.lerp(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(mouse.x, mouse.y, particlePos.z), mouseStrength);\n                    } else {\n                        // Otherwise, move the particle back to its original position\n                        particlePos.lerp(originalPos, 0.05);\n                    }\n                    // Use the noise function to get a smooth, varying value for each particle\n                    const noiseValue = noise3DFunction(particlePos.x, particlePos.y, time);\n                    // Use the noise value to adjust the position of the particle\n                    particlePos.z += noiseValue * 0.01; // adjust the multiplier to control the amplitude of the animation\n                    positions[i] = particlePos.x;\n                    positions[i + 1] = particlePos.y;\n                    positions[i + 2] = particlePos.z;\n                }\n            }\n            particlesGeometry.attributes.position.needsUpdate = true;\n            //renderer.render(scene, camera);\n            composer.render();\n            requestAnimationFrame(animate);\n        }\n        animate();\n    });\n    camera.position.z = 1.38;\n    //camera.position.y += 10; // Adjust this value as needed\n    window.addEventListener(\"resize\", ()=>{\n        const newWidth = window.innerWidth;\n        const newHeight = window.innerHeight;\n        camera.aspect = newWidth / newHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(newWidth, newHeight);\n        composer.setSize(newWidth, newHeight);\n    });\n    let deviceOrientationActive = false;\n    window.addEventListener(\"deviceorientation\", function(event) {\n        deviceOrientationActive = true;\n        var alpha = event.alpha;\n        var beta = event.beta;\n        var gamma = event.gamma;\n        // Convert degrees to radians\n        var alphaRad = alpha * (Math.PI / 180);\n        var betaRad = beta * (Math.PI / 180);\n        var gammaRad = gamma * (Math.PI / 180);\n        // Apply rotation to the camera\n        camera.rotation.set(betaRad, alphaRad, -gammaRad);\n    }, true);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQzVDLEdBQUc7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9hcHAuanM/YzI0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IEVmZmVjdENvbXBvc2VyIH0gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9FZmZlY3RDb21wb3Nlci5qc1wiO1xuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvUmVuZGVyUGFzcy5qc1wiO1xuaW1wb3J0IHsgVW5yZWFsQmxvb21QYXNzIH0gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9VbnJlYWxCbG9vbVBhc3MuanNcIjtcbmltcG9ydCB7IGNyZWF0ZU5vaXNlM0QgfSBmcm9tICdzaW1wbGV4LW5vaXNlJztcbmltcG9ydCB7IEdMVEZMb2FkZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyLmpzJztcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9scy5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplVGhyZWVKUyhtb3VudFBvaW50KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgbm9pc2UgZ2VuZXJhdG9yXG4gICAgY29uc3Qgbm9pc2UzREZ1bmN0aW9uID0gY3JlYXRlTm9pc2UzRCgpO1xuXG4gICAgY29uc3QgbW91c2VSYWRpdXMgPSAwLjAyOyAvLyBBZGp1c3QgdGhpcyB2YWx1ZSBhcyBuZWVkZWRcbiAgICBjb25zdCBtb3VzZVN0cmVuZ3RoID0gMC4wMDU7IC8vIEFkanVzdCB0aGlzIHZhbHVlIGFzIG5lZWRlZCwgaWYgbm90IGRlZmluZWQgZWxzZXdoZXJlXG5cblxuICAgIC8vIFNldCB1cCB0aGUgc2NlbmUsIGNhbWVyYSwgYW5kIHJlbmRlcmVyXG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwMDApO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbHBoYTogdHJ1ZSB9KTtcbiAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIC8vcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweDAwMDAwMCwgMCk7XG4gICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweEY1RjVEQywgMSk7IC8vIEJlaWdlIGNvbG9yXG5cbiAgICBtb3VudFBvaW50LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRWZmZWN0IENvbXBvc2VyXG4gICAgY29uc3QgY29tcG9zZXIgPSBuZXcgRWZmZWN0Q29tcG9zZXIocmVuZGVyZXIpO1xuXG4gICAgY29uc3QgcmVuZGVyUGFzcyA9IG5ldyBSZW5kZXJQYXNzKHNjZW5lLCBjYW1lcmEpO1xuICAgIGNvbXBvc2VyLmFkZFBhc3MocmVuZGVyUGFzcyk7XG5cbiAgICBjb25zdCBibG9vbU9wdGlvbnMgPSB7XG4gICAgICAgIHN0cmVuZ3RoOiAwLjQ2NSxcbiAgICAgICAgcmFkaXVzOiAwLjMsXG4gICAgICAgIHRocmVzaG9sZDogMFxuICAgIH07XG4gICAgY29uc3QgYmxvb21QYXNzID0gbmV3IFVucmVhbEJsb29tUGFzcyhuZXcgVEhSRUUuVmVjdG9yMih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSwgYmxvb21PcHRpb25zLnN0cmVuZ3RoLCBibG9vbU9wdGlvbnMucmFkaXVzLCBibG9vbU9wdGlvbnMudGhyZXNob2xkKTtcbiAgICBjb21wb3Nlci5hZGRQYXNzKGJsb29tUGFzcyk7XG5cbiAgICAvLyBEZWZpbmUgdGhlIHRleHR1cmVMb2FkZXIgaGVyZVxuICAgIGNvbnN0IHRleHR1cmVMb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xuXG4gICAgbGV0IG1vdXNlID0gbmV3IFRIUkVFLlZlY3RvcjIoMTAwMDAsIDEwMDAwKTtcbiAgICBsZXQgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuXG4gICAgY29uc3QgY2FtZXJhUGFyYWxsYXhGYWN0b3IgPSAwLjU7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHtcbiAgICAgICAgbW91c2UueCA9IChlLmNsaWVudFggLyB3aW5kb3cuaW5uZXJXaWR0aCkgKiAyIC0gMTtcbiAgICAgICAgbW91c2UueSA9IC0oZS5jbGllbnRZIC8gd2luZG93LmlubmVySGVpZ2h0KSAqIDIgKyAxO1xuICAgICAgICBtb3VzZS56ID0gZ2V0QXZlcmFnZVBhcnRpY2xlWigpO1xuXG4gICAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlLCBjYW1lcmEpO1xuXG4gICAgICAgIGlmICghcmF5Y2FzdGVyLnJheSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignUmF5Y2FzdGVyIHJheSBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47IC8vIEV4aXQgdGhlIGZ1bmN0aW9uIGVhcmx5IHRvIHByZXZlbnQgZnVydGhlciBlcnJvcnNcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnRlcnNlY3RQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJheWNhc3Rlci5yYXkuYXQoMS4zLCBpbnRlcnNlY3RQb2ludCk7XG5cbiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggKz0gKGludGVyc2VjdFBvaW50LnggKiBjYW1lcmFQYXJhbGxheEZhY3RvciAtIGNhbWVyYS5wb3NpdGlvbi54KSAqIDAuMDU7XG4gICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ICs9ICgtaW50ZXJzZWN0UG9pbnQueSAqIGNhbWVyYVBhcmFsbGF4RmFjdG9yIC0gY2FtZXJhLnBvc2l0aW9uLnkpICogMC4wNTtcbiAgICAgICAgXG4gICAgICAgIGNhbWVyYS5sb29rQXQoc2NlbmUucG9zaXRpb24pO1xuXG5cblxuICAgIH0pO1xuICAgIGNvbnN0IGNvbnRyb2xzID0gbmV3IE9yYml0Q29udHJvbHMoY2FtZXJhLCByZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICBjb250cm9scy5lbmFibGVSb3RhdGUgPSBmYWxzZTtcbmNvbnRyb2xzLmVuYWJsZVBhbiA9IGZhbHNlO1xuY29udHJvbHMuZW5hYmxlWm9vbSA9IHRydWU7XG4vLyBQcmV2ZW50IHRoZSBjYW1lcmEgZnJvbSBnb2luZyB1bmRlciB0aGUgYXhpc1xuY29udHJvbHMubWluUG9sYXJBbmdsZSA9IDA7IC8vIFByZXZlbnRzIHRoZSBjYW1lcmEgZnJvbSBnb2luZyBiZWxvdyB0aGUgaG9yaXpvbnRhbCBwbGFuZVxuY29udHJvbHMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEkgLyAyOyAvLyBQcmV2ZW50cyB0aGUgY2FtZXJhIGZyb20gZ29pbmcgYWJvdmUgdGhlIGhvcml6b250YWwgcGxhbmVcbiAgICAvLyBEZWZpbmUgcGFydGljbGVzR2VvbWV0cnkgaW4gdGhlIG91dGVyIHNjb3BlXG4gICAgbGV0IHBhcnRpY2xlc0dlb21ldHJ5O1xuICAgIGNvbnN0IGFtYmllbnRMaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoMHhmZmZmZmYsIDAuOCk7IC8vIHNvZnQgd2hpdGUgbGlnaHRcbiAgICBzY2VuZS5hZGQoYW1iaWVudExpZ2h0KTtcbiAgICBcbiAgICBjb25zdCBkaXJlY3Rpb25hbExpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDAuMSk7XG4gICAgZGlyZWN0aW9uYWxMaWdodC5wb3NpdGlvbi5zZXQoMCwgMSwgMSk7IC8vIHNldCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaWdodFxuICAgIHNjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0KTtcblxuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBHTFRGTG9hZGVyKCk7XG5cbmxvYWRlci5sb2FkKCdzdXNoaXJlc3R1cmFudGtpdC9zY2VuZS5nbHRmJywgZnVuY3Rpb24gKGdsdGYpIHtcbiAgICBcbiAgICBzY2VuZS5hZGQoZ2x0Zi5zY2VuZSk7XG4gICAgc2NlbmUucG9zaXRpb24ueSAtPSAxOyAvLyBMb3dlciB0aGUgc2NlbmUgYnkgNSB1bml0c1xufSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn0pO1xuXG5zY2VuZS5yb3RhdGlvbi55IC09IE1hdGguUEkgLyAyO1xuICAgIHRleHR1cmVMb2FkZXIubG9hZCgnc2tyaWxsZXgyMDIzbG9nby5wbmcnLCAoaW1hZ2VUZXh0dXJlKSA9PiB7XG4gICAgICAgIC8vIC4uLlxuICAgICAgICAvLyAgcGFydGljbGVzR2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgLy8gLi4uXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ2V0QXZlcmFnZVBhcnRpY2xlWigpIHtcbiAgICAgICAgaWYgKCFwYXJ0aWNsZXNHZW9tZXRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gcGFydGljbGVzR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICAgICAgbGV0IHRvdGFsWiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICB0b3RhbFogKz0gcG9zaXRpb25zW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbFogLyAocG9zaXRpb25zLmxlbmd0aCAvIDMpO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVRvdWNoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgaGFuZGxlVG91Y2gpO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2goZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0b3VjaCA9IGUudG91Y2hlc1swXTtcblxuICAgICAgICAgICAgbW91c2UueCA9ICh0b3VjaC5jbGllbnRYIC8gd2luZG93LmlubmVyV2lkdGgpICogMiAtIDE7XG4gICAgICAgICAgICBtb3VzZS55ID0gLSh0b3VjaC5jbGllbnRZIC8gd2luZG93LmlubmVySGVpZ2h0KSAqIDIgKyAxO1xuICAgICAgICAgICAgbW91c2UueiA9IGdldEF2ZXJhZ2VQYXJ0aWNsZVooKTtcblxuICAgICAgICAgICAgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEobW91c2UsIGNhbWVyYSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdFBvaW50ID0gcmF5Y2FzdGVyLnJheS5hdCgxLjMpO1xuXG4gICAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueCArPSAoaW50ZXJzZWN0UG9pbnQueCAqIGNhbWVyYVBhcmFsbGF4RmFjdG9yIC0gY2FtZXJhLnBvc2l0aW9uLngpICogMC4wNTtcbiAgICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ICs9ICgtaW50ZXJzZWN0UG9pbnQueSAqIGNhbWVyYVBhcmFsbGF4RmFjdG9yIC0gY2FtZXJhLnBvc2l0aW9uLnkpICogMC4wNSA7XG4gICAgICAgICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgKz0gKC1pbnRlcnNlY3RQb2ludC55ICogY2FtZXJhUGFyYWxsYXhGYWN0b3IgLSBjYW1lcmEucG9zaXRpb24ueSkgKiAwLjA1ICsgMTA7IC8vIEFkanVzdCB0aGlzIHZhbHVlIGFzIG5lZWRlZFxuXG4gICAgICAgICAgICBjYW1lcmEubG9va0F0KHNjZW5lLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBhIG5ldyBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIGF2ZXJhZ2Ugei1jb29yZGluYXRlIG9mIGFsbCBwYXJ0aWNsZXNcblxuICAgIH1cbiAgICBjb25zdCBzY2FsZSA9IDQ7IC8vIEFkanVzdCB0aGlzIHZhbHVlIGZvciB5b3VyIGRlc2lyZWQgc2NhbGUuIEUuZy4sIDAuNSBtZWFucyB0aGUgaW1hZ2Ugd2lsbCBiZSA1MCUgc21hbGxlclxuXG4gICAgdGV4dHVyZUxvYWRlci5sb2FkKCdjaXJjbGUucG5nJywgKGltYWdlVGV4dHVyZSkgPT4ge1xuICAgICAgICBjb25zdCBpbWdXaWR0aCA9IGltYWdlVGV4dHVyZS5pbWFnZS53aWR0aCAqIHNjYWxlO1xuICAgICAgICBjb25zdCBpbWdIZWlnaHQgPSBpbWFnZVRleHR1cmUuaW1hZ2UuaGVpZ2h0ICogc2NhbGU7XG5cbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGltZ1dpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nSGVpZ2h0O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2VUZXh0dXJlLmltYWdlLCAwLCAwLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcblxuICAgICAgICBjb25zdCBpbWdEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCkuZGF0YTtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbkZhY3RvciA9IDM7XG5cbiAgICAgICAgY29uc3QgcGFydGljbGVUZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCdwYXJ0aWNsZXMyLnBuZycpO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZXNHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZVZlcnRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlQ29sb3JzID0gW107XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUG9zaXRpb25zID0gW107XG4gICAgICAgIGNvbnN0IGluY3JlYXNlZEJyaWdodG5lc3MgPSAyLjI1OyAvLyBQbGFjZSB0aGlzIGJlZm9yZSB0aGUgbG9vcFxuXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaW1nSGVpZ2h0OyB5ICs9IHJlc29sdXRpb25GYWN0b3IpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgaW1nV2lkdGg7IHggKz0gcmVzb2x1dGlvbkZhY3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gKHkgKiBpbWdXaWR0aCArIHgpICogNDtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gaW1nRGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IGltZ0RhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gaW1nRGF0YVtpbmRleCArIDJdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYnJpZ2h0bmVzcyA9IDAuNzE1MiAqIHIgKyAwLjIxMjYgKiBnICsgMC4wNzIyICogYjtcbiAgICAgICAgICAgICAgICBpZiAoYnJpZ2h0bmVzcyA+IDEyOCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4UG9zID0gKHggLyBpbWdXaWR0aCAtIDAuNSkgKiAyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5UG9zID0gKHkgLyBpbWdIZWlnaHQgLSAwLjUpICogLTI7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlVmVydGljZXMucHVzaCh4UG9zLCB5UG9zLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxQb3NpdGlvbnMucHVzaCh4UG9zLCB5UG9zLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGVDb2xvcnMucHVzaCgociAvIDI1NSkgKiBpbmNyZWFzZWRCcmlnaHRuZXNzICogMC44LCAoZyAvIDI1NSkgKiBpbmNyZWFzZWRCcmlnaHRuZXNzLCAoYiAvIDI1NSkgKiBpbmNyZWFzZWRCcmlnaHRuZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFydGljbGVDb2xvcnMucHVzaCgxLCAwLCAwKTsgLy8gU2V0IFJHQiB2YWx1ZXMgdG8gKDEsIDAsIDApIGZvciByZWRcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcGFydGljbGVzR2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBhcnRpY2xlVmVydGljZXMsIDMpKTtcbiAgICAgICAgcGFydGljbGVzR2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBhcnRpY2xlQ29sb3JzLCAzKSk7XG5cbiAgICAgICAgY29uc3QgcGFydGljbGVzTWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoe1xuICAgICAgICAgICAgc2l6ZTogMC4wMixcbiAgICAgICAgICAgIG1hcDogcGFydGljbGVUZXh0dXJlLFxuICAgICAgICAgICAgdmVydGV4Q29sb3JzOiB0cnVlLFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLCAvLyBBZGp1c3QgdGhpcyB2YWx1ZVxuXG5cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlcyA9IG5ldyBUSFJFRS5Qb2ludHMocGFydGljbGVzR2VvbWV0cnksIHBhcnRpY2xlc01hdGVyaWFsKTtcbiAgICAgICAgLy9zY2VuZS5hZGQocGFydGljbGVzKTtcblxuXG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IDE7IC8vIFJlcGxhY2Ugd2l0aCB0aGUgZGVzaXJlZCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IDMyOyAvLyBSZXBsYWNlIHdpdGggdGhlIGRlc2lyZWQgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGFwcHJveGltYXRlIHRoZSBjaXJjbGVcblxuICAgICAgICBjb25zdCBjaXJjbGVUZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCdjaXJjbGU0LnBuZycpO1xuICAgICAgICBjb25zdCBjaXJjbGVNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogY2lyY2xlVGV4dHVyZSB9KTtcbiAgICAgICAgY29uc3QgY2lyY2xlR2VvbWV0cnkgPSBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkocmFkaXVzLCBzZWdtZW50cyk7XG4gICAgICAgIGNvbnN0IGNpcmNsZU1lc2ggPSBuZXcgVEhSRUUuTWVzaChjaXJjbGVHZW9tZXRyeSwgY2lyY2xlTWF0ZXJpYWwpO1xuICAgICAgICBjaXJjbGVNZXNoLnBvc2l0aW9uLnNldCgwLCAwLCAtMik7XG4gICAgICAgIGNpcmNsZU1lc2gucm90YXRpb24uc2V0KDAsIDAsIDApO1xuICAgICAgICAvL3NjZW5lLmFkZChjaXJjbGVNZXNoKTtcblxuICAgICAgICAvLyBUaGVuLCBpbiB5b3VyIGFuaW1hdGUgZnVuY3Rpb246XG4gICAgICAgIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBwYXJ0aWNsZXNHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgICAgICAgICAgY29uc3QgdGltZSA9IERhdGUubm93KCkgKiAwLjAwMDE7ICAvLyBhZGp1c3QgdGhlIG11bHRpcGxpZXIgdG8gY29udHJvbCB0aGUgc3BlZWQgb2YgdGhlIGFuaW1hdGlvblxuICAgICAgICBcbiAgICAgICAgICAgIGlmICghZGV2aWNlT3JpZW50YXRpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBjb250cm9scy51cGRhdGUoKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRpY2xlUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMocG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdLCBwb3NpdGlvbnNbaSArIDJdKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMob3JpZ2luYWxQb3NpdGlvbnNbaV0sIG9yaWdpbmFsUG9zaXRpb25zW2kgKyAxXSwgb3JpZ2luYWxQb3NpdGlvbnNbaSArIDJdKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcGFydGljbGUgYW5kIHRoZSBtb3VzZVxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2VUb01vdXNlID0gcGFydGljbGVQb3MuZGlzdGFuY2VUbyhtb3VzZSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlzdGFuY2UgaXMgbGVzcyB0aGFuIHRoZSBtb3VzZVJhZGl1cywgbW92ZSB0aGUgcGFydGljbGUgdG93YXJkcyB0aGUgbW91c2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlVG9Nb3VzZSA8IG1vdXNlUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZVBvcy5sZXJwKG5ldyBUSFJFRS5WZWN0b3IzKG1vdXNlLngsIG1vdXNlLnksIHBhcnRpY2xlUG9zLnopLCBtb3VzZVN0cmVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgbW92ZSB0aGUgcGFydGljbGUgYmFjayB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlUG9zLmxlcnAob3JpZ2luYWxQb3MsIDAuMDUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIG5vaXNlIGZ1bmN0aW9uIHRvIGdldCBhIHNtb290aCwgdmFyeWluZyB2YWx1ZSBmb3IgZWFjaCBwYXJ0aWNsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2lzZVZhbHVlID0gbm9pc2UzREZ1bmN0aW9uKHBhcnRpY2xlUG9zLngsIHBhcnRpY2xlUG9zLnksIHRpbWUpO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBub2lzZSB2YWx1ZSB0byBhZGp1c3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBwYXJ0aWNsZVxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZVBvcy56ICs9IG5vaXNlVmFsdWUgKiAwLjAxOyAgLy8gYWRqdXN0IHRoZSBtdWx0aXBsaWVyIHRvIGNvbnRyb2wgdGhlIGFtcGxpdHVkZSBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbaV0gPSBwYXJ0aWNsZVBvcy54O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbaSArIDFdID0gcGFydGljbGVQb3MueTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2kgKyAyXSA9IHBhcnRpY2xlUG9zLno7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHBhcnRpY2xlc0dlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgICAgICAgY29tcG9zZXIucmVuZGVyKCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhbmltYXRlKCk7XG4gICAgfSk7XG5cbiAgICBjYW1lcmEucG9zaXRpb24ueiA9IDEuMzg7XG4gICAgLy9jYW1lcmEucG9zaXRpb24ueSArPSAxMDsgLy8gQWRqdXN0IHRoaXMgdmFsdWUgYXMgbmVlZGVkXG5cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgICBjYW1lcmEuYXNwZWN0ID0gbmV3V2lkdGggLyBuZXdIZWlnaHQ7XG4gICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgY29tcG9zZXIuc2V0U2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICB9KTtcbiAgICBsZXQgZGV2aWNlT3JpZW50YXRpb25BY3RpdmUgPSBmYWxzZTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VvcmllbnRhdGlvbicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBkZXZpY2VPcmllbnRhdGlvbkFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHZhciBhbHBoYSA9IGV2ZW50LmFscGhhO1xuICAgICAgICB2YXIgYmV0YSA9IGV2ZW50LmJldGE7XG4gICAgICAgIHZhciBnYW1tYSA9IGV2ZW50LmdhbW1hO1xuICAgIFxuICAgICAgICAvLyBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICAgICAgICB2YXIgYWxwaGFSYWQgPSBhbHBoYSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgdmFyIGJldGFSYWQgPSBiZXRhICogKE1hdGguUEkgLyAxODApO1xuICAgICAgICB2YXIgZ2FtbWFSYWQgPSBnYW1tYSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICBcbiAgICAgICAgLy8gQXBwbHkgcm90YXRpb24gdG8gdGhlIGNhbWVyYVxuICAgICAgICBjYW1lcmEucm90YXRpb24uc2V0KGJldGFSYWQsIGFscGhhUmFkLCAtZ2FtbWFSYWQpO1xuICAgIH0sIHRydWUpO1xufSJdLCJuYW1lcyI6WyJUSFJFRSIsIkVmZmVjdENvbXBvc2VyIiwiUmVuZGVyUGFzcyIsIlVucmVhbEJsb29tUGFzcyIsImNyZWF0ZU5vaXNlM0QiLCJHTFRGTG9hZGVyIiwiT3JiaXRDb250cm9scyIsImluaXRpYWxpemVUaHJlZUpTIiwibW91bnRQb2ludCIsIm5vaXNlM0RGdW5jdGlvbiIsIm1vdXNlUmFkaXVzIiwibW91c2VTdHJlbmd0aCIsInNjZW5lIiwiU2NlbmUiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsImFscGhhIiwic2V0U2l6ZSIsInNldENsZWFyQ29sb3IiLCJhcHBlbmRDaGlsZCIsImRvbUVsZW1lbnQiLCJjb21wb3NlciIsInJlbmRlclBhc3MiLCJhZGRQYXNzIiwiYmxvb21PcHRpb25zIiwic3RyZW5ndGgiLCJyYWRpdXMiLCJ0aHJlc2hvbGQiLCJibG9vbVBhc3MiLCJWZWN0b3IyIiwidGV4dHVyZUxvYWRlciIsIlRleHR1cmVMb2FkZXIiLCJtb3VzZSIsInJheWNhc3RlciIsIlJheWNhc3RlciIsImNhbWVyYVBhcmFsbGF4RmFjdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwieiIsImdldEF2ZXJhZ2VQYXJ0aWNsZVoiLCJzZXRGcm9tQ2FtZXJhIiwicmF5IiwiY29uc29sZSIsImVycm9yIiwiaW50ZXJzZWN0UG9pbnQiLCJWZWN0b3IzIiwiYXQiLCJwb3NpdGlvbiIsImxvb2tBdCIsImNvbnRyb2xzIiwiZW5hYmxlUm90YXRlIiwiZW5hYmxlUGFuIiwiZW5hYmxlWm9vbSIsIm1pblBvbGFyQW5nbGUiLCJtYXhQb2xhckFuZ2xlIiwiTWF0aCIsIlBJIiwicGFydGljbGVzR2VvbWV0cnkiLCJhbWJpZW50TGlnaHQiLCJBbWJpZW50TGlnaHQiLCJhZGQiLCJkaXJlY3Rpb25hbExpZ2h0IiwiRGlyZWN0aW9uYWxMaWdodCIsInNldCIsImxvYWRlciIsImxvYWQiLCJnbHRmIiwidW5kZWZpbmVkIiwicm90YXRpb24iLCJpbWFnZVRleHR1cmUiLCJwb3NpdGlvbnMiLCJhdHRyaWJ1dGVzIiwiYXJyYXkiLCJ0b3RhbFoiLCJpIiwibGVuZ3RoIiwiaGFuZGxlVG91Y2giLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJ0b3VjaCIsInNjYWxlIiwiaW1nV2lkdGgiLCJpbWFnZSIsIndpZHRoIiwiaW1nSGVpZ2h0IiwiaGVpZ2h0IiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY29udGV4dCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJpbWdEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiZGF0YSIsInJlc29sdXRpb25GYWN0b3IiLCJwYXJ0aWNsZVRleHR1cmUiLCJCdWZmZXJHZW9tZXRyeSIsInBhcnRpY2xlVmVydGljZXMiLCJwYXJ0aWNsZUNvbG9ycyIsIm9yaWdpbmFsUG9zaXRpb25zIiwiaW5jcmVhc2VkQnJpZ2h0bmVzcyIsImluZGV4IiwiciIsImciLCJiIiwiYnJpZ2h0bmVzcyIsInhQb3MiLCJ5UG9zIiwicHVzaCIsInNldEF0dHJpYnV0ZSIsIkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUiLCJwYXJ0aWNsZXNNYXRlcmlhbCIsIlBvaW50c01hdGVyaWFsIiwic2l6ZSIsIm1hcCIsInZlcnRleENvbG9ycyIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsInBhcnRpY2xlcyIsIlBvaW50cyIsInNlZ21lbnRzIiwiY2lyY2xlVGV4dHVyZSIsImNpcmNsZU1hdGVyaWFsIiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJjaXJjbGVHZW9tZXRyeSIsIkNpcmNsZUdlb21ldHJ5IiwiY2lyY2xlTWVzaCIsIk1lc2giLCJhbmltYXRlIiwidGltZSIsIkRhdGUiLCJub3ciLCJkZXZpY2VPcmllbnRhdGlvbkFjdGl2ZSIsInVwZGF0ZSIsInBhcnRpY2xlUG9zIiwib3JpZ2luYWxQb3MiLCJkaXN0YW5jZVRvTW91c2UiLCJkaXN0YW5jZVRvIiwibGVycCIsIm5vaXNlVmFsdWUiLCJuZWVkc1VwZGF0ZSIsInJlbmRlciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsImV2ZW50IiwiYmV0YSIsImdhbW1hIiwiYWxwaGFSYWQiLCJiZXRhUmFkIiwiZ2FtbWFSYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/app.js\n"));

/***/ })

});