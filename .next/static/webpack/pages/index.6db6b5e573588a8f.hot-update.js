"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/app.js":
/*!**********************!*\
  !*** ./utils/app.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeThreeJS: function() { return /* binding */ initializeThreeJS; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer.js */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var simplex_noise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! simplex-noise */ \"./node_modules/simplex-noise/dist/esm/simplex-noise.js\");\n/* harmony import */ var three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader.js */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\n\n\n\n\n\nfunction initializeThreeJS(mountPoint) {\n    // Initialize the noise generator\n    const noise3DFunction = (0,simplex_noise__WEBPACK_IMPORTED_MODULE_0__.createNoise3D)();\n    const mouseRadius = 0.2; // Adjust this value as needed\n    const mouseStrength = 0.05; // Adjust this value as needed, if not defined elsewhere\n    // Set up the scene, camera, and renderer\n    const scene = new three__WEBPACK_IMPORTED_MODULE_1__.Scene();\n    const camera = new three__WEBPACK_IMPORTED_MODULE_1__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    const renderer = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer({\n        alpha: true\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    //renderer.setClearColor(0x000000, 0);\n    mountPoint.appendChild(renderer.domElement);\n    // Initialize the Effect Composer\n    const composer = new three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_2__.EffectComposer(renderer);\n    const renderPass = new three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__.RenderPass(scene, camera);\n    composer.addPass(renderPass);\n    const bloomOptions = {\n        strength: 2.5,\n        radius: 0.6,\n        threshold: 0\n    };\n    const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_4__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(window.innerWidth, window.innerHeight), bloomOptions.strength, bloomOptions.radius, bloomOptions.threshold);\n    composer.addPass(bloomPass);\n    // Define the textureLoader here\n    const textureLoader = new three__WEBPACK_IMPORTED_MODULE_1__.TextureLoader();\n    let mouse = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(10000, 10000);\n    let raycaster = new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();\n    const cameraParallaxFactor = 0.5;\n    window.addEventListener(\"mousemove\", (e)=>{\n        mouse.x = e.clientX / window.innerWidth * 2 - 1;\n        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n        mouse.z = getAverageParticleZ();\n        raycaster.setFromCamera(mouse, camera);\n        if (!raycaster.ray) {\n            console.error(\"Raycaster ray is not initialized.\");\n            return; // Exit the function early to prevent further errors\n        }\n        let intersectPoint = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        raycaster.ray.at(1.3, intersectPoint);\n        camera.position.x += (intersectPoint.x * cameraParallaxFactor - camera.position.x) * 0.05;\n        camera.position.y += (-intersectPoint.y * cameraParallaxFactor - camera.position.y) * 0.05;\n        camera.lookAt(scene.position);\n    });\n    // Define particlesGeometry in the outer scope\n    let particlesGeometry;\n    const ambientLight = new three__WEBPACK_IMPORTED_MODULE_1__.AmbientLight(0xffffff, 0.6); // soft white light\n    scene.add(ambientLight);\n    const directionalLight = new three__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(0xffffff, 0.6);\n    directionalLight.position.set(0, 1, 1); // set the direction of the light\n    scene.add(directionalLight);\n    const loader = new three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader();\n    loader.load(\"kawaiiscene/scene.gltf\", function(gltf) {\n        scene.add(gltf.scene);\n    }, undefined, function(error) {\n        console.error(error);\n    });\n    textureLoader.load(\"skrillex2023logo.png\", (imageTexture)=>{\n    // ...\n    //  particlesGeometry = new THREE.BufferGeometry();\n    // ...\n    });\n    function getAverageParticleZ() {\n        if (!particlesGeometry) {\n            return 0;\n        }\n        const positions = particlesGeometry.attributes.position.array;\n        let totalZ = 0;\n        for(let i = 2; i < positions.length; i += 3){\n            totalZ += positions[i];\n        }\n        return totalZ / (positions.length / 3);\n    }\n    window.addEventListener(\"touchstart\", handleTouch);\n    window.addEventListener(\"touchmove\", handleTouch);\n    function handleTouch(e) {\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouse.x = touch.clientX / window.innerWidth * 2 - 1;\n            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;\n            mouse.z = getAverageParticleZ();\n            raycaster.setFromCamera(mouse, camera);\n            const intersectPoint = raycaster.ray.at(1.3);\n            camera.position.x += (intersectPoint.x * cameraParallaxFactor - camera.position.x) * 0.05;\n            camera.position.y += (-intersectPoint.y * cameraParallaxFactor - camera.position.y) * 0.05;\n            camera.lookAt(scene.position);\n        }\n    // Add a new function to calculate the average z-coordinate of all particles\n    }\n    const scale = 4; // Adjust this value for your desired scale. E.g., 0.5 means the image will be 50% smaller\n    textureLoader.load(\"circle.png\", (imageTexture)=>{\n        const imgWidth = imageTexture.image.width * scale;\n        const imgHeight = imageTexture.image.height * scale;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = imgWidth;\n        canvas.height = imgHeight;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(imageTexture.image, 0, 0, imgWidth, imgHeight);\n        const imgData = context.getImageData(0, 0, imgWidth, imgHeight).data;\n        const resolutionFactor = 3;\n        const particleTexture = textureLoader.load(\"particles2.png\");\n        const particlesGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n        const particleVertices = [];\n        const particleColors = [];\n        const originalPositions = [];\n        const increasedBrightness = 2.25; // Place this before the loop\n        for(let y = 0; y < imgHeight; y += resolutionFactor){\n            for(let x = 0; x < imgWidth; x += resolutionFactor){\n                const index = (y * imgWidth + x) * 4;\n                const r = imgData[index];\n                const g = imgData[index + 1];\n                const b = imgData[index + 2];\n                const brightness = 0.7152 * r + 0.2126 * g + 0.0722 * b;\n                if (brightness > 128) {\n                    const xPos = (x / imgWidth - 0.5) * 2;\n                    const yPos = (y / imgHeight - 0.5) * -2;\n                    particleVertices.push(xPos, yPos, 0);\n                    originalPositions.push(xPos, yPos, 0);\n                    particleColors.push(r / 255 * increasedBrightness * 0.8, g / 255 * increasedBrightness, b / 255 * increasedBrightness);\n                }\n                particleColors.push(1, 0, 0); // Set RGB values to (1, 0, 0) for red\n            }\n        }\n        particlesGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleVertices, 3));\n        particlesGeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleColors, 3));\n        const particlesMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.PointsMaterial({\n            size: 0.02,\n            map: particleTexture,\n            vertexColors: true,\n            transparent: true,\n            opacity: 1\n        });\n        const particles = new three__WEBPACK_IMPORTED_MODULE_1__.Points(particlesGeometry, particlesMaterial);\n        //scene.add(particles);\n        const radius = 1; // Replace with the desired radius of the circle\n        const segments = 32; // Replace with the desired number of segments to approximate the circle\n        const circleTexture = textureLoader.load(\"circle4.png\");\n        const circleMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            map: circleTexture\n        });\n        const circleGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.CircleGeometry(radius, segments);\n        const circleMesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(circleGeometry, circleMaterial);\n        circleMesh.position.set(0, 0, -2);\n        circleMesh.rotation.set(0, 0, 0);\n        //scene.add(circleMesh);\n        // Then, in your animate function:\n        function animate() {\n            const positions = particlesGeometry.attributes.position.array;\n            const time = Date.now() * 0.0001; // adjust the multiplier to control the speed of the animation\n            for(let i = 0; i < positions.length; i += 3){\n                let particlePos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(positions[i], positions[i + 1], positions[i + 2]);\n                let originalPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(originalPositions[i], originalPositions[i + 1], originalPositions[i + 2]);\n                // Calculate the distance between the particle and the mouse\n                let distanceToMouse = particlePos.distanceTo(mouse);\n                // If the distance is less than the mouseRadius, move the particle towards the mouse\n                if (distanceToMouse < mouseRadius) {\n                    particlePos.lerp(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(mouse.x, mouse.y, particlePos.z), mouseStrength);\n                } else {\n                    // Otherwise, move the particle back to its original position\n                    particlePos.lerp(originalPos, 0.05);\n                }\n                // Use the noise function to get a smooth, varying value for each particle\n                const noiseValue = noise3DFunction(particlePos.x, particlePos.y, time);\n                // Use the noise value to adjust the position of the particle\n                particlePos.z += noiseValue * 0.01; // adjust the multiplier to control the amplitude of the animation\n                positions[i] = particlePos.x;\n                positions[i + 1] = particlePos.y;\n                positions[i + 2] = particlePos.z;\n            }\n            particlesGeometry.attributes.position.needsUpdate = true;\n            //renderer.render(scene, camera);\n            composer.render();\n            requestAnimationFrame(animate);\n        }\n        animate();\n    });\n    camera.position.z = 1.38;\n    window.addEventListener(\"resize\", ()=>{\n        const newWidth = window.innerWidth;\n        const newHeight = window.innerHeight;\n        camera.aspect = newWidth / newHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(newWidth, newHeight);\n        composer.setSize(newWidth, newHeight);\n    });\n    window.addEventListener(\"deviceorientation\", function(event) {\n        var alpha = event.alpha;\n        var beta = event.beta;\n        var gamma = event.gamma;\n        // Convert degrees to radians\n        var alphaRad = alpha * (Math.PI / 180);\n        var betaRad = beta * (Math.PI / 180);\n        var gammaRad = gamma * (Math.PI / 180);\n        // Apply rotation to the camera\n        camera.rotation.set(betaRad, alphaRad, -gammaRad);\n    }, true);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SCxLQUFLO1FBQ3ZCLElBQUk4SCxPQUFPRCxNQUFNQyxJQUFJO1FBQ3JCLElBQUlDLFFBQVFGLE1BQU1FLEtBQUs7UUFFdkIsNkJBQTZCO1FBQzdCLElBQUlDLFdBQVdoSSxRQUFTaUksQ0FBQUEsS0FBS0MsRUFBRSxHQUFHLEdBQUU7UUFDcEMsSUFBSUMsVUFBVUwsT0FBUUcsQ0FBQUEsS0FBS0MsRUFBRSxHQUFHLEdBQUU7UUFDbEMsSUFBSUUsV0FBV0wsUUFBU0UsQ0FBQUEsS0FBS0MsRUFBRSxHQUFHLEdBQUU7UUFFcEMsK0JBQStCO1FBQy9CekksT0FBT2tILFFBQVEsQ0FBQ2pFLEdBQUcsQ0FBQ3lGLFNBQVNILFVBQVUsQ0FBQ0k7SUFDNUMsR0FBRztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2FwcC5qcz9jMjQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgRWZmZWN0Q29tcG9zZXIgfSBmcm9tIFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL0VmZmVjdENvbXBvc2VyLmpzXCI7XG5pbXBvcnQgeyBSZW5kZXJQYXNzIH0gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9SZW5kZXJQYXNzLmpzXCI7XG5pbXBvcnQgeyBVbnJlYWxCbG9vbVBhc3MgfSBmcm9tIFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcy5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlTm9pc2UzRCB9IGZyb20gJ3NpbXBsZXgtbm9pc2UnO1xuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXIuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZVRocmVlSlMobW91bnRQb2ludCkge1xuICAgIC8vIEluaXRpYWxpemUgdGhlIG5vaXNlIGdlbmVyYXRvclxuICAgIGNvbnN0IG5vaXNlM0RGdW5jdGlvbiA9IGNyZWF0ZU5vaXNlM0QoKTtcblxuICAgIGNvbnN0IG1vdXNlUmFkaXVzID0gMC4yOyAvLyBBZGp1c3QgdGhpcyB2YWx1ZSBhcyBuZWVkZWRcbiAgICBjb25zdCBtb3VzZVN0cmVuZ3RoID0gMC4wNTsgLy8gQWRqdXN0IHRoaXMgdmFsdWUgYXMgbmVlZGVkLCBpZiBub3QgZGVmaW5lZCBlbHNld2hlcmVcblxuXG4gICAgLy8gU2V0IHVwIHRoZSBzY2VuZSwgY2FtZXJhLCBhbmQgcmVuZGVyZXJcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgIGNvbnN0IGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgMTAwMCk7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7IGFscGhhOiB0cnVlIH0pO1xuICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgLy9yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAwKTtcblxuICAgIG1vdW50UG9pbnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBFZmZlY3QgQ29tcG9zZXJcbiAgICBjb25zdCBjb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihyZW5kZXJlcik7XG5cbiAgICBjb25zdCByZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSk7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhyZW5kZXJQYXNzKTtcblxuICAgIGNvbnN0IGJsb29tT3B0aW9ucyA9IHtcbiAgICAgICAgc3RyZW5ndGg6IDIuNSxcbiAgICAgICAgcmFkaXVzOiAwLjYsXG4gICAgICAgIHRocmVzaG9sZDogMFxuICAgIH07XG4gICAgY29uc3QgYmxvb21QYXNzID0gbmV3IFVucmVhbEJsb29tUGFzcyhuZXcgVEhSRUUuVmVjdG9yMih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSwgYmxvb21PcHRpb25zLnN0cmVuZ3RoLCBibG9vbU9wdGlvbnMucmFkaXVzLCBibG9vbU9wdGlvbnMudGhyZXNob2xkKTtcbiAgICBjb21wb3Nlci5hZGRQYXNzKGJsb29tUGFzcyk7XG5cbiAgICAvLyBEZWZpbmUgdGhlIHRleHR1cmVMb2FkZXIgaGVyZVxuICAgIGNvbnN0IHRleHR1cmVMb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xuXG4gICAgbGV0IG1vdXNlID0gbmV3IFRIUkVFLlZlY3RvcjIoMTAwMDAsIDEwMDAwKTtcbiAgICBsZXQgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuXG4gICAgY29uc3QgY2FtZXJhUGFyYWxsYXhGYWN0b3IgPSAwLjU7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHtcbiAgICAgICAgbW91c2UueCA9IChlLmNsaWVudFggLyB3aW5kb3cuaW5uZXJXaWR0aCkgKiAyIC0gMTtcbiAgICAgICAgbW91c2UueSA9IC0oZS5jbGllbnRZIC8gd2luZG93LmlubmVySGVpZ2h0KSAqIDIgKyAxO1xuICAgICAgICBtb3VzZS56ID0gZ2V0QXZlcmFnZVBhcnRpY2xlWigpO1xuXG4gICAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlLCBjYW1lcmEpO1xuXG4gICAgICAgIGlmICghcmF5Y2FzdGVyLnJheSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignUmF5Y2FzdGVyIHJheSBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47IC8vIEV4aXQgdGhlIGZ1bmN0aW9uIGVhcmx5IHRvIHByZXZlbnQgZnVydGhlciBlcnJvcnNcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnRlcnNlY3RQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHJheWNhc3Rlci5yYXkuYXQoMS4zLCBpbnRlcnNlY3RQb2ludCk7XG5cbiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggKz0gKGludGVyc2VjdFBvaW50LnggKiBjYW1lcmFQYXJhbGxheEZhY3RvciAtIGNhbWVyYS5wb3NpdGlvbi54KSAqIDAuMDU7XG4gICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ICs9ICgtaW50ZXJzZWN0UG9pbnQueSAqIGNhbWVyYVBhcmFsbGF4RmFjdG9yIC0gY2FtZXJhLnBvc2l0aW9uLnkpICogMC4wNTtcbiAgICAgICAgY2FtZXJhLmxvb2tBdChzY2VuZS5wb3NpdGlvbik7XG4gICAgfSk7XG4gICAgLy8gRGVmaW5lIHBhcnRpY2xlc0dlb21ldHJ5IGluIHRoZSBvdXRlciBzY29wZVxuICAgIGxldCBwYXJ0aWNsZXNHZW9tZXRyeTtcbiAgICBjb25zdCBhbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4ZmZmZmZmLCAwLjYpOyAvLyBzb2Z0IHdoaXRlIGxpZ2h0XG4gICAgc2NlbmUuYWRkKGFtYmllbnRMaWdodCk7XG4gICAgXG4gICAgY29uc3QgZGlyZWN0aW9uYWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAwLjYpO1xuICAgIGRpcmVjdGlvbmFsTGlnaHQucG9zaXRpb24uc2V0KDAsIDEsIDEpOyAvLyBzZXQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGlnaHRcbiAgICBzY2VuZS5hZGQoZGlyZWN0aW9uYWxMaWdodCk7XG5cbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgR0xURkxvYWRlcigpO1xuXG5sb2FkZXIubG9hZCgna2F3YWlpc2NlbmUvc2NlbmUuZ2x0ZicsIGZ1bmN0aW9uIChnbHRmKSB7XG4gICAgc2NlbmUuYWRkKGdsdGYuc2NlbmUpO1xufSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn0pO1xuXG4gICAgdGV4dHVyZUxvYWRlci5sb2FkKCdza3JpbGxleDIwMjNsb2dvLnBuZycsIChpbWFnZVRleHR1cmUpID0+IHtcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIC8vICBwYXJ0aWNsZXNHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgICAvLyAuLi5cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBnZXRBdmVyYWdlUGFydGljbGVaKCkge1xuICAgICAgICBpZiAoIXBhcnRpY2xlc0dlb21ldHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBwYXJ0aWNsZXNHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgICAgICBsZXQgdG90YWxaID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHRvdGFsWiArPSBwb3NpdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsWiAvIChwb3NpdGlvbnMubGVuZ3RoIC8gMyk7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2gpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVUb3VjaCk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuXG4gICAgICAgICAgICBtb3VzZS54ID0gKHRvdWNoLmNsaWVudFggLyB3aW5kb3cuaW5uZXJXaWR0aCkgKiAyIC0gMTtcbiAgICAgICAgICAgIG1vdXNlLnkgPSAtKHRvdWNoLmNsaWVudFkgLyB3aW5kb3cuaW5uZXJIZWlnaHQpICogMiArIDE7XG4gICAgICAgICAgICBtb3VzZS56ID0gZ2V0QXZlcmFnZVBhcnRpY2xlWigpO1xuXG4gICAgICAgICAgICByYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShtb3VzZSwgY2FtZXJhKTtcblxuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0UG9pbnQgPSByYXljYXN0ZXIucmF5LmF0KDEuMyk7XG5cbiAgICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi54ICs9IChpbnRlcnNlY3RQb2ludC54ICogY2FtZXJhUGFyYWxsYXhGYWN0b3IgLSBjYW1lcmEucG9zaXRpb24ueCkgKiAwLjA1O1xuICAgICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgKz0gKC1pbnRlcnNlY3RQb2ludC55ICogY2FtZXJhUGFyYWxsYXhGYWN0b3IgLSBjYW1lcmEucG9zaXRpb24ueSkgKiAwLjA1O1xuICAgICAgICAgICAgY2FtZXJhLmxvb2tBdChzY2VuZS5wb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGEgbmV3IGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgYXZlcmFnZSB6LWNvb3JkaW5hdGUgb2YgYWxsIHBhcnRpY2xlc1xuXG4gICAgfVxuICAgIGNvbnN0IHNjYWxlID0gNDsgLy8gQWRqdXN0IHRoaXMgdmFsdWUgZm9yIHlvdXIgZGVzaXJlZCBzY2FsZS4gRS5nLiwgMC41IG1lYW5zIHRoZSBpbWFnZSB3aWxsIGJlIDUwJSBzbWFsbGVyXG5cbiAgICB0ZXh0dXJlTG9hZGVyLmxvYWQoJ2NpcmNsZS5wbmcnLCAoaW1hZ2VUZXh0dXJlKSA9PiB7XG4gICAgICAgIGNvbnN0IGltZ1dpZHRoID0gaW1hZ2VUZXh0dXJlLmltYWdlLndpZHRoICogc2NhbGU7XG4gICAgICAgIGNvbnN0IGltZ0hlaWdodCA9IGltYWdlVGV4dHVyZS5pbWFnZS5oZWlnaHQgKiBzY2FsZTtcblxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gaW1nV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWdIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZVRleHR1cmUuaW1hZ2UsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuXG4gICAgICAgIGNvbnN0IGltZ0RhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KS5kYXRhO1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uRmFjdG9yID0gMztcblxuICAgICAgICBjb25zdCBwYXJ0aWNsZVRleHR1cmUgPSB0ZXh0dXJlTG9hZGVyLmxvYWQoJ3BhcnRpY2xlczIucG5nJyk7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlc0dlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlVmVydGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcGFydGljbGVDb2xvcnMgPSBbXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgaW5jcmVhc2VkQnJpZ2h0bmVzcyA9IDIuMjU7IC8vIFBsYWNlIHRoaXMgYmVmb3JlIHRoZSBsb29wXG5cbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBpbWdIZWlnaHQ7IHkgKz0gcmVzb2x1dGlvbkZhY3Rvcikge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBpbWdXaWR0aDsgeCArPSByZXNvbHV0aW9uRmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSAoeSAqIGltZ1dpZHRoICsgeCkgKiA0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBpbWdEYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gaW1nRGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBpbWdEYXRhW2luZGV4ICsgMl07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBicmlnaHRuZXNzID0gMC43MTUyICogciArIDAuMjEyNiAqIGcgKyAwLjA3MjIgKiBiO1xuICAgICAgICAgICAgICAgIGlmIChicmlnaHRuZXNzID4gMTI4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhQb3MgPSAoeCAvIGltZ1dpZHRoIC0gMC41KSAqIDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHlQb3MgPSAoeSAvIGltZ0hlaWdodCAtIDAuNSkgKiAtMjtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGVWZXJ0aWNlcy5wdXNoKHhQb3MsIHlQb3MsIDApO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFBvc2l0aW9ucy5wdXNoKHhQb3MsIHlQb3MsIDApO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZUNvbG9ycy5wdXNoKChyIC8gMjU1KSAqIGluY3JlYXNlZEJyaWdodG5lc3MgKiAwLjgsIChnIC8gMjU1KSAqIGluY3JlYXNlZEJyaWdodG5lc3MsIChiIC8gMjU1KSAqIGluY3JlYXNlZEJyaWdodG5lc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJ0aWNsZUNvbG9ycy5wdXNoKDEsIDAsIDApOyAvLyBTZXQgUkdCIHZhbHVlcyB0byAoMSwgMCwgMCkgZm9yIHJlZFxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0aWNsZXNHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocGFydGljbGVWZXJ0aWNlcywgMykpO1xuICAgICAgICBwYXJ0aWNsZXNHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocGFydGljbGVDb2xvcnMsIDMpKTtcblxuICAgICAgICBjb25zdCBwYXJ0aWNsZXNNYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7XG4gICAgICAgICAgICBzaXplOiAwLjAyLFxuICAgICAgICAgICAgbWFwOiBwYXJ0aWNsZVRleHR1cmUsXG4gICAgICAgICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsIC8vIEFkanVzdCB0aGlzIHZhbHVlXG5cblxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFydGljbGVzID0gbmV3IFRIUkVFLlBvaW50cyhwYXJ0aWNsZXNHZW9tZXRyeSwgcGFydGljbGVzTWF0ZXJpYWwpO1xuICAgICAgICAvL3NjZW5lLmFkZChwYXJ0aWNsZXMpO1xuXG5cbiAgICAgICAgY29uc3QgcmFkaXVzID0gMTsgLy8gUmVwbGFjZSB3aXRoIHRoZSBkZXNpcmVkIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gMzI7IC8vIFJlcGxhY2Ugd2l0aCB0aGUgZGVzaXJlZCBudW1iZXIgb2Ygc2VnbWVudHMgdG8gYXBwcm94aW1hdGUgdGhlIGNpcmNsZVxuXG4gICAgICAgIGNvbnN0IGNpcmNsZVRleHR1cmUgPSB0ZXh0dXJlTG9hZGVyLmxvYWQoJ2NpcmNsZTQucG5nJyk7XG4gICAgICAgIGNvbnN0IGNpcmNsZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiBjaXJjbGVUZXh0dXJlIH0pO1xuICAgICAgICBjb25zdCBjaXJjbGVHZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShyYWRpdXMsIHNlZ21lbnRzKTtcbiAgICAgICAgY29uc3QgY2lyY2xlTWVzaCA9IG5ldyBUSFJFRS5NZXNoKGNpcmNsZUdlb21ldHJ5LCBjaXJjbGVNYXRlcmlhbCk7XG4gICAgICAgIGNpcmNsZU1lc2gucG9zaXRpb24uc2V0KDAsIDAsIC0yKTtcbiAgICAgICAgY2lyY2xlTWVzaC5yb3RhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgICAgIC8vc2NlbmUuYWRkKGNpcmNsZU1lc2gpO1xuXG4gICAgICAgIC8vIFRoZW4sIGluIHlvdXIgYW5pbWF0ZSBmdW5jdGlvbjpcbiAgICAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHBhcnRpY2xlc0dlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKSAqIDAuMDAwMTsgIC8vIGFkanVzdCB0aGUgbXVsdGlwbGllciB0byBjb250cm9sIHRoZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uXG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnRpY2xlUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMocG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdLCBwb3NpdGlvbnNbaSArIDJdKTtcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ2luYWxQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMyhvcmlnaW5hbFBvc2l0aW9uc1tpXSwgb3JpZ2luYWxQb3NpdGlvbnNbaSArIDFdLCBvcmlnaW5hbFBvc2l0aW9uc1tpICsgMl0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwYXJ0aWNsZSBhbmQgdGhlIG1vdXNlXG4gICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlVG9Nb3VzZSA9IHBhcnRpY2xlUG9zLmRpc3RhbmNlVG8obW91c2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgbW91c2VSYWRpdXMsIG1vdmUgdGhlIHBhcnRpY2xlIHRvd2FyZHMgdGhlIG1vdXNlXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlVG9Nb3VzZSA8IG1vdXNlUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlUG9zLmxlcnAobmV3IFRIUkVFLlZlY3RvcjMobW91c2UueCwgbW91c2UueSwgcGFydGljbGVQb3MueiksIG1vdXNlU3RyZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgbW92ZSB0aGUgcGFydGljbGUgYmFjayB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGVQb3MubGVycChvcmlnaW5hbFBvcywgMC4wNSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBub2lzZSBmdW5jdGlvbiB0byBnZXQgYSBzbW9vdGgsIHZhcnlpbmcgdmFsdWUgZm9yIGVhY2ggcGFydGljbGVcbiAgICAgICAgICAgICAgICBjb25zdCBub2lzZVZhbHVlID0gbm9pc2UzREZ1bmN0aW9uKHBhcnRpY2xlUG9zLngsIHBhcnRpY2xlUG9zLnksIHRpbWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBub2lzZSB2YWx1ZSB0byBhZGp1c3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBwYXJ0aWNsZVxuICAgICAgICAgICAgICAgIHBhcnRpY2xlUG9zLnogKz0gbm9pc2VWYWx1ZSAqIDAuMDE7ICAvLyBhZGp1c3QgdGhlIG11bHRpcGxpZXIgdG8gY29udHJvbCB0aGUgYW1wbGl0dWRlIG9mIHRoZSBhbmltYXRpb25cblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tpXSA9IHBhcnRpY2xlUG9zLng7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zW2kgKyAxXSA9IHBhcnRpY2xlUG9zLnk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zW2kgKyAyXSA9IHBhcnRpY2xlUG9zLno7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRpY2xlc0dlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvL3JlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgICAgICAgIGNvbXBvc2VyLnJlbmRlcigpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbWF0ZSgpO1xuICAgIH0pO1xuXG4gICAgY2FtZXJhLnBvc2l0aW9uLnogPSAxLjM4O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgIGNhbWVyYS5hc3BlY3QgPSBuZXdXaWR0aCAvIG5ld0hlaWdodDtcbiAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgICAgICByZW5kZXJlci5zZXRTaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICBjb21wb3Nlci5zZXRTaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZW9yaWVudGF0aW9uJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBhbHBoYSA9IGV2ZW50LmFscGhhO1xuICAgICAgICB2YXIgYmV0YSA9IGV2ZW50LmJldGE7XG4gICAgICAgIHZhciBnYW1tYSA9IGV2ZW50LmdhbW1hO1xuXG4gICAgICAgIC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gICAgICAgIHZhciBhbHBoYVJhZCA9IGFscGhhICogKE1hdGguUEkgLyAxODApO1xuICAgICAgICB2YXIgYmV0YVJhZCA9IGJldGEgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIHZhciBnYW1tYVJhZCA9IGdhbW1hICogKE1hdGguUEkgLyAxODApO1xuXG4gICAgICAgIC8vIEFwcGx5IHJvdGF0aW9uIHRvIHRoZSBjYW1lcmFcbiAgICAgICAgY2FtZXJhLnJvdGF0aW9uLnNldChiZXRhUmFkLCBhbHBoYVJhZCwgLWdhbW1hUmFkKTtcbiAgICB9LCB0cnVlKTtcbn0iXSwibmFtZXMiOlsiVEhSRUUiLCJFZmZlY3RDb21wb3NlciIsIlJlbmRlclBhc3MiLCJVbnJlYWxCbG9vbVBhc3MiLCJjcmVhdGVOb2lzZTNEIiwiR0xURkxvYWRlciIsImluaXRpYWxpemVUaHJlZUpTIiwibW91bnRQb2ludCIsIm5vaXNlM0RGdW5jdGlvbiIsIm1vdXNlUmFkaXVzIiwibW91c2VTdHJlbmd0aCIsInNjZW5lIiwiU2NlbmUiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsImFscGhhIiwic2V0U2l6ZSIsImFwcGVuZENoaWxkIiwiZG9tRWxlbWVudCIsImNvbXBvc2VyIiwicmVuZGVyUGFzcyIsImFkZFBhc3MiLCJibG9vbU9wdGlvbnMiLCJzdHJlbmd0aCIsInJhZGl1cyIsInRocmVzaG9sZCIsImJsb29tUGFzcyIsIlZlY3RvcjIiLCJ0ZXh0dXJlTG9hZGVyIiwiVGV4dHVyZUxvYWRlciIsIm1vdXNlIiwicmF5Y2FzdGVyIiwiUmF5Y2FzdGVyIiwiY2FtZXJhUGFyYWxsYXhGYWN0b3IiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJ6IiwiZ2V0QXZlcmFnZVBhcnRpY2xlWiIsInNldEZyb21DYW1lcmEiLCJyYXkiLCJjb25zb2xlIiwiZXJyb3IiLCJpbnRlcnNlY3RQb2ludCIsIlZlY3RvcjMiLCJhdCIsInBvc2l0aW9uIiwibG9va0F0IiwicGFydGljbGVzR2VvbWV0cnkiLCJhbWJpZW50TGlnaHQiLCJBbWJpZW50TGlnaHQiLCJhZGQiLCJkaXJlY3Rpb25hbExpZ2h0IiwiRGlyZWN0aW9uYWxMaWdodCIsInNldCIsImxvYWRlciIsImxvYWQiLCJnbHRmIiwidW5kZWZpbmVkIiwiaW1hZ2VUZXh0dXJlIiwicG9zaXRpb25zIiwiYXR0cmlidXRlcyIsImFycmF5IiwidG90YWxaIiwiaSIsImxlbmd0aCIsImhhbmRsZVRvdWNoIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaGVzIiwidG91Y2giLCJzY2FsZSIsImltZ1dpZHRoIiwiaW1hZ2UiLCJ3aWR0aCIsImltZ0hlaWdodCIsImhlaWdodCIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbnRleHQiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwiaW1nRGF0YSIsImdldEltYWdlRGF0YSIsImRhdGEiLCJyZXNvbHV0aW9uRmFjdG9yIiwicGFydGljbGVUZXh0dXJlIiwiQnVmZmVyR2VvbWV0cnkiLCJwYXJ0aWNsZVZlcnRpY2VzIiwicGFydGljbGVDb2xvcnMiLCJvcmlnaW5hbFBvc2l0aW9ucyIsImluY3JlYXNlZEJyaWdodG5lc3MiLCJpbmRleCIsInIiLCJnIiwiYiIsImJyaWdodG5lc3MiLCJ4UG9zIiwieVBvcyIsInB1c2giLCJzZXRBdHRyaWJ1dGUiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwicGFydGljbGVzTWF0ZXJpYWwiLCJQb2ludHNNYXRlcmlhbCIsInNpemUiLCJtYXAiLCJ2ZXJ0ZXhDb2xvcnMiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiLCJwYXJ0aWNsZXMiLCJQb2ludHMiLCJzZWdtZW50cyIsImNpcmNsZVRleHR1cmUiLCJjaXJjbGVNYXRlcmlhbCIsIk1lc2hCYXNpY01hdGVyaWFsIiwiY2lyY2xlR2VvbWV0cnkiLCJDaXJjbGVHZW9tZXRyeSIsImNpcmNsZU1lc2giLCJNZXNoIiwicm90YXRpb24iLCJhbmltYXRlIiwidGltZSIsIkRhdGUiLCJub3ciLCJwYXJ0aWNsZVBvcyIsIm9yaWdpbmFsUG9zIiwiZGlzdGFuY2VUb01vdXNlIiwiZGlzdGFuY2VUbyIsImxlcnAiLCJub2lzZVZhbHVlIiwibmVlZHNVcGRhdGUiLCJyZW5kZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJldmVudCIsImJldGEiLCJnYW1tYSIsImFscGhhUmFkIiwiTWF0aCIsIlBJIiwiYmV0YVJhZCIsImdhbW1hUmFkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/app.js\n"));

/***/ })

});