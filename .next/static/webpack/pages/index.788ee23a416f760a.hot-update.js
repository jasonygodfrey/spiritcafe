"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/app.js":
/*!**********************!*\
  !*** ./utils/app.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeThreeJS: function() { return /* binding */ initializeThreeJS; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer.js */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var simplex_noise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! simplex-noise */ \"./node_modules/simplex-noise/dist/esm/simplex-noise.js\");\n/* harmony import */ var three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader.js */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n/* harmony import */ var three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls.js */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\n\n\n\n\n\n\nfunction initializeThreeJS(mountPoint) {\n    // Initialize the noise generator\n    const noise3DFunction = (0,simplex_noise__WEBPACK_IMPORTED_MODULE_0__.createNoise3D)();\n    const mouseRadius = 0.02; // Adjust this value as needed\n    const mouseStrength = 0.005; // Adjust this value as needed, if not defined elsewhere\n    // Set up the scene, camera, and renderer\n    const scene = new three__WEBPACK_IMPORTED_MODULE_1__.Scene();\n    const camera = new three__WEBPACK_IMPORTED_MODULE_1__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    const renderer = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer({\n        alpha: true\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    //renderer.setClearColor(0x000000, 0);\n    renderer.setClearColor(0xF5F5DC, 1); // Beige color\n    mountPoint.appendChild(renderer.domElement);\n    // Initialize the Effect Composer\n    const composer = new three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_2__.EffectComposer(renderer);\n    const renderPass = new three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__.RenderPass(scene, camera);\n    composer.addPass(renderPass);\n    const bloomOptions = {\n        strength: 0.465,\n        radius: 0.3,\n        threshold: 0\n    };\n    const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_4__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(window.innerWidth, window.innerHeight), bloomOptions.strength, bloomOptions.radius, bloomOptions.threshold);\n    composer.addPass(bloomPass);\n    // Define the textureLoader here\n    const textureLoader = new three__WEBPACK_IMPORTED_MODULE_1__.TextureLoader();\n    let mouse = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(10000, 10000);\n    let raycaster = new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();\n    const cameraParallaxFactor = 0.5;\n    window.addEventListener(\"mousemove\", (e)=>{\n        mouse.x = e.clientX / window.innerWidth * 2 - 1;\n        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n        mouse.z = getAverageParticleZ();\n        raycaster.setFromCamera(mouse, camera);\n        if (!raycaster.ray) {\n            console.error(\"Raycaster ray is not initialized.\");\n            return; // Exit the function early to prevent further errors\n        }\n        let intersectPoint1 = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        raycaster.ray.at(1.3, intersectPoint1);\n        camera.position.x += (intersectPoint1.x * cameraParallaxFactor - camera.position.x) * 0.05;\n        camera.position.y += (-intersectPoint1.y * cameraParallaxFactor - camera.position.y) * 0.05;\n        camera.lookAt(scene.position);\n    });\n    const controls = new three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_5__.OrbitControls(camera, renderer.domElement);\n    controls.enableRotate = false;\n    controls.enablePan = false;\n    controls.enableZoom = true;\n    // Prevent the camera from going under the axis\n    controls.minPolarAngle = 0; // Prevents the camera from going below the horizontal plane\n    controls.maxPolarAngle = Math.PI / 2; // Prevents the camera from going above the horizontal plane\n    // Define particlesGeometry in the outer scope\n    let particlesGeometry;\n    const ambientLight = new three__WEBPACK_IMPORTED_MODULE_1__.AmbientLight(0xffffff, 0.8); // soft white light\n    scene.add(ambientLight);\n    const directionalLight = new three__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(0xffffff, 0.1);\n    directionalLight.position.set(0, 1, 1); // set the direction of the light\n    scene.add(directionalLight);\n    const loader = new three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_6__.GLTFLoader();\n    loader.load(\"kawaiiscene/scene.gltf\", function(gltf) {\n        scene.add(gltf.scene);\n    }, undefined, function(error) {\n        console.error(error);\n    });\n    scene.rotation.y -= Math.PI / 2;\n    textureLoader.load(\"skrillex2023logo.png\", (imageTexture)=>{\n    // ...\n    //  particlesGeometry = new THREE.BufferGeometry();\n    // ...\n    });\n    function getAverageParticleZ() {\n        if (!particlesGeometry) {\n            return 0;\n        }\n        const positions = particlesGeometry.attributes.position.array;\n        let totalZ = 0;\n        for(let i = 2; i < positions.length; i += 3){\n            totalZ += positions[i];\n        }\n        return totalZ / (positions.length / 3);\n    }\n    window.addEventListener(\"touchstart\", handleTouch);\n    window.addEventListener(\"touchmove\", handleTouch);\n    function handleTouch(e) {\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouse.x = touch.clientX / window.innerWidth * 2 - 1;\n            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;\n            mouse.z = getAverageParticleZ();\n            raycaster.setFromCamera(mouse, camera);\n            const intersectPoint1 = raycaster.ray.at(1.3);\n            camera.position.x += (intersectPoint1.x * cameraParallaxFactor - camera.position.x) * 0.05;\n            camera.position.y += (-intersectPoint1.y * cameraParallaxFactor - camera.position.y) * 0.05;\n            camera.lookAt(scene.position);\n        }\n        camera.position.y += (-intersectPoint.y * cameraParallaxFactor - camera.position.y) * 0.05 + 30; // Adjust this value as needed\n    // Add a new function to calculate the average z-coordinate of all particles\n    }\n    const scale = 4; // Adjust this value for your desired scale. E.g., 0.5 means the image will be 50% smaller\n    textureLoader.load(\"circle.png\", (imageTexture)=>{\n        const imgWidth = imageTexture.image.width * scale;\n        const imgHeight = imageTexture.image.height * scale;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = imgWidth;\n        canvas.height = imgHeight;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(imageTexture.image, 0, 0, imgWidth, imgHeight);\n        const imgData = context.getImageData(0, 0, imgWidth, imgHeight).data;\n        const resolutionFactor = 3;\n        const particleTexture = textureLoader.load(\"particles2.png\");\n        const particlesGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n        const particleVertices = [];\n        const particleColors = [];\n        const originalPositions = [];\n        const increasedBrightness = 2.25; // Place this before the loop\n        for(let y = 0; y < imgHeight; y += resolutionFactor){\n            for(let x = 0; x < imgWidth; x += resolutionFactor){\n                const index = (y * imgWidth + x) * 4;\n                const r = imgData[index];\n                const g = imgData[index + 1];\n                const b = imgData[index + 2];\n                const brightness = 0.7152 * r + 0.2126 * g + 0.0722 * b;\n                if (brightness > 128) {\n                    const xPos = (x / imgWidth - 0.5) * 2;\n                    const yPos = (y / imgHeight - 0.5) * -2;\n                    particleVertices.push(xPos, yPos, 0);\n                    originalPositions.push(xPos, yPos, 0);\n                    particleColors.push(r / 255 * increasedBrightness * 0.8, g / 255 * increasedBrightness, b / 255 * increasedBrightness);\n                }\n                particleColors.push(1, 0, 0); // Set RGB values to (1, 0, 0) for red\n            }\n        }\n        particlesGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleVertices, 3));\n        particlesGeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleColors, 3));\n        const particlesMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.PointsMaterial({\n            size: 0.02,\n            map: particleTexture,\n            vertexColors: true,\n            transparent: true,\n            opacity: 1\n        });\n        const particles = new three__WEBPACK_IMPORTED_MODULE_1__.Points(particlesGeometry, particlesMaterial);\n        //scene.add(particles);\n        const radius = 1; // Replace with the desired radius of the circle\n        const segments = 32; // Replace with the desired number of segments to approximate the circle\n        const circleTexture = textureLoader.load(\"circle4.png\");\n        const circleMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            map: circleTexture\n        });\n        const circleGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.CircleGeometry(radius, segments);\n        const circleMesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(circleGeometry, circleMaterial);\n        circleMesh.position.set(0, 0, -2);\n        circleMesh.rotation.set(0, 0, 0);\n        //scene.add(circleMesh);\n        // Then, in your animate function:\n        function animate() {\n            const positions = particlesGeometry.attributes.position.array;\n            const time = Date.now() * 0.0001; // adjust the multiplier to control the speed of the animation\n            controls.update();\n            for(let i = 0; i < positions.length; i += 3){\n                let particlePos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(positions[i], positions[i + 1], positions[i + 2]);\n                let originalPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(originalPositions[i], originalPositions[i + 1], originalPositions[i + 2]);\n                // Calculate the distance between the particle and the mouse\n                let distanceToMouse = particlePos.distanceTo(mouse);\n                // If the distance is less than the mouseRadius, move the particle towards the mouse\n                if (distanceToMouse < mouseRadius) {\n                    particlePos.lerp(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(mouse.x, mouse.y, particlePos.z), mouseStrength);\n                } else {\n                    // Otherwise, move the particle back to its original position\n                    particlePos.lerp(originalPos, 0.05);\n                }\n                // Use the noise function to get a smooth, varying value for each particle\n                const noiseValue = noise3DFunction(particlePos.x, particlePos.y, time);\n                // Use the noise value to adjust the position of the particle\n                particlePos.z += noiseValue * 0.01; // adjust the multiplier to control the amplitude of the animation\n                positions[i] = particlePos.x;\n                positions[i + 1] = particlePos.y;\n                positions[i + 2] = particlePos.z;\n            }\n            particlesGeometry.attributes.position.needsUpdate = true;\n            //renderer.render(scene, camera);\n            composer.render();\n            requestAnimationFrame(animate);\n        }\n        animate();\n    });\n    camera.position.z = 1.38;\n    camera.position.y += 10; // Adjust this value as needed\n    window.addEventListener(\"resize\", ()=>{\n        const newWidth = window.innerWidth;\n        const newHeight = window.innerHeight;\n        camera.aspect = newWidth / newHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(newWidth, newHeight);\n        composer.setSize(newWidth, newHeight);\n    });\n    window.addEventListener(\"deviceorientation\", function(event) {\n        var alpha = event.alpha;\n        var beta = event.beta;\n        var gamma = event.gamma;\n        // Convert degrees to radians\n        var alphaRad = alpha * (Math.PI / 180);\n        var betaRad = beta * (Math.PI / 180);\n        var gammaRad = gamma * (Math.PI / 180);\n        // Apply rotation to the camera\n        camera.rotation.set(betaRad, alphaRad, -gammaRad);\n    }, true);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgRWZmZWN0Q29tcG9zZXIgfSBmcm9tIFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL0VmZmVjdENvbXBvc2VyLmpzXCI7XG5pbXBvcnQgeyBSZW5kZXJQYXNzIH0gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9SZW5kZXJQYXNzLmpzXCI7XG5pbXBvcnQgeyBVbnJlYWxCbG9vbVBhc3MgfSBmcm9tIFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcy5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlTm9pc2UzRCB9IGZyb20gJ3NpbXBsZXgtbm9pc2UnO1xuaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXIuanMnO1xuaW1wb3J0IHsgT3JiaXRDb250cm9scyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9jb250cm9scy9PcmJpdENvbnRyb2xzLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVUaHJlZUpTKG1vdW50UG9pbnQpIHtcbiAgICAvLyBJbml0aWFsaXplIHRoZSBub2lzZSBnZW5lcmF0b3JcbiAgICBjb25zdCBub2lzZTNERnVuY3Rpb24gPSBjcmVhdGVOb2lzZTNEKCk7XG5cbiAgICBjb25zdCBtb3VzZVJhZGl1cyA9IDAuMDI7IC8vIEFkanVzdCB0aGlzIHZhbHVlIGFzIG5lZWRlZFxuICAgIGNvbnN0IG1vdXNlU3RyZW5ndGggPSAwLjAwNTsgLy8gQWRqdXN0IHRoaXMgdmFsdWUgYXMgbmVlZGVkLCBpZiBub3QgZGVmaW5lZCBlbHNld2hlcmVcblxuXG4gICAgLy8gU2V0IHVwIHRoZSBzY2VuZSwgY2FtZXJhLCBhbmQgcmVuZGVyZXJcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgIGNvbnN0IGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgMTAwMCk7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7IGFscGhhOiB0cnVlIH0pO1xuICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgLy9yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAwKTtcbiAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4RjVGNURDLCAxKTsgLy8gQmVpZ2UgY29sb3JcblxuICAgIG1vdW50UG9pbnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBFZmZlY3QgQ29tcG9zZXJcbiAgICBjb25zdCBjb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihyZW5kZXJlcik7XG5cbiAgICBjb25zdCByZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSk7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhyZW5kZXJQYXNzKTtcblxuICAgIGNvbnN0IGJsb29tT3B0aW9ucyA9IHtcbiAgICAgICAgc3RyZW5ndGg6IDAuNDY1LFxuICAgICAgICByYWRpdXM6IDAuMyxcbiAgICAgICAgdGhyZXNob2xkOiAwXG4gICAgfTtcbiAgICBjb25zdCBibG9vbVBhc3MgPSBuZXcgVW5yZWFsQmxvb21QYXNzKG5ldyBUSFJFRS5WZWN0b3IyKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpLCBibG9vbU9wdGlvbnMuc3RyZW5ndGgsIGJsb29tT3B0aW9ucy5yYWRpdXMsIGJsb29tT3B0aW9ucy50aHJlc2hvbGQpO1xuICAgIGNvbXBvc2VyLmFkZFBhc3MoYmxvb21QYXNzKTtcblxuICAgIC8vIERlZmluZSB0aGUgdGV4dHVyZUxvYWRlciBoZXJlXG4gICAgY29uc3QgdGV4dHVyZUxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCk7XG5cbiAgICBsZXQgbW91c2UgPSBuZXcgVEhSRUUuVmVjdG9yMigxMDAwMCwgMTAwMDApO1xuICAgIGxldCByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKCk7XG5cbiAgICBjb25zdCBjYW1lcmFQYXJhbGxheEZhY3RvciA9IDAuNTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xuICAgICAgICBtb3VzZS54ID0gKGUuY2xpZW50WCAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIDIgLSAxO1xuICAgICAgICBtb3VzZS55ID0gLShlLmNsaWVudFkgLyB3aW5kb3cuaW5uZXJIZWlnaHQpICogMiArIDE7XG4gICAgICAgIG1vdXNlLnogPSBnZXRBdmVyYWdlUGFydGljbGVaKCk7XG5cbiAgICAgICAgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEobW91c2UsIGNhbWVyYSk7XG5cbiAgICAgICAgaWYgKCFyYXljYXN0ZXIucmF5KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdSYXljYXN0ZXIgcmF5IGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICAgICAgICAgIHJldHVybjsgLy8gRXhpdCB0aGUgZnVuY3Rpb24gZWFybHkgdG8gcHJldmVudCBmdXJ0aGVyIGVycm9yc1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGludGVyc2VjdFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgcmF5Y2FzdGVyLnJheS5hdCgxLjMsIGludGVyc2VjdFBvaW50KTtcblxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueCArPSAoaW50ZXJzZWN0UG9pbnQueCAqIGNhbWVyYVBhcmFsbGF4RmFjdG9yIC0gY2FtZXJhLnBvc2l0aW9uLngpICogMC4wNTtcbiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgKz0gKC1pbnRlcnNlY3RQb2ludC55ICogY2FtZXJhUGFyYWxsYXhGYWN0b3IgLSBjYW1lcmEucG9zaXRpb24ueSkgKiAwLjA1O1xuICAgICAgICBcbiAgICAgICAgY2FtZXJhLmxvb2tBdChzY2VuZS5wb3NpdGlvbik7XG5cblxuXG4gICAgfSk7XG4gICAgY29uc3QgY29udHJvbHMgPSBuZXcgT3JiaXRDb250cm9scyhjYW1lcmEsIHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIGNvbnRyb2xzLmVuYWJsZVJvdGF0ZSA9IGZhbHNlO1xuY29udHJvbHMuZW5hYmxlUGFuID0gZmFsc2U7XG5jb250cm9scy5lbmFibGVab29tID0gdHJ1ZTtcbi8vIFByZXZlbnQgdGhlIGNhbWVyYSBmcm9tIGdvaW5nIHVuZGVyIHRoZSBheGlzXG5jb250cm9scy5taW5Qb2xhckFuZ2xlID0gMDsgLy8gUHJldmVudHMgdGhlIGNhbWVyYSBmcm9tIGdvaW5nIGJlbG93IHRoZSBob3Jpem9udGFsIHBsYW5lXG5jb250cm9scy5tYXhQb2xhckFuZ2xlID0gTWF0aC5QSSAvIDI7IC8vIFByZXZlbnRzIHRoZSBjYW1lcmEgZnJvbSBnb2luZyBhYm92ZSB0aGUgaG9yaXpvbnRhbCBwbGFuZVxuICAgIC8vIERlZmluZSBwYXJ0aWNsZXNHZW9tZXRyeSBpbiB0aGUgb3V0ZXIgc2NvcGVcbiAgICBsZXQgcGFydGljbGVzR2VvbWV0cnk7XG4gICAgY29uc3QgYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCgweGZmZmZmZiwgMC44KTsgLy8gc29mdCB3aGl0ZSBsaWdodFxuICAgIHNjZW5lLmFkZChhbWJpZW50TGlnaHQpO1xuICAgIFxuICAgIGNvbnN0IGRpcmVjdGlvbmFsTGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweGZmZmZmZiwgMC4xKTtcbiAgICBkaXJlY3Rpb25hbExpZ2h0LnBvc2l0aW9uLnNldCgwLCAxLCAxKTsgLy8gc2V0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpZ2h0XG4gICAgc2NlbmUuYWRkKGRpcmVjdGlvbmFsTGlnaHQpO1xuXG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEdMVEZMb2FkZXIoKTtcblxubG9hZGVyLmxvYWQoJ2thd2FpaXNjZW5lL3NjZW5lLmdsdGYnLCBmdW5jdGlvbiAoZ2x0Zikge1xuICAgIFxuICAgIHNjZW5lLmFkZChnbHRmLnNjZW5lKTtcbn0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG59KTtcblxuc2NlbmUucm90YXRpb24ueSAtPSBNYXRoLlBJIC8gMjtcbiAgICB0ZXh0dXJlTG9hZGVyLmxvYWQoJ3NrcmlsbGV4MjAyM2xvZ28ucG5nJywgKGltYWdlVGV4dHVyZSkgPT4ge1xuICAgICAgICAvLyAuLi5cbiAgICAgICAgLy8gIHBhcnRpY2xlc0dlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICAgIC8vIC4uLlxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGdldEF2ZXJhZ2VQYXJ0aWNsZVooKSB7XG4gICAgICAgIGlmICghcGFydGljbGVzR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHBhcnRpY2xlc0dlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgICAgIGxldCB0b3RhbFogPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgdG90YWxaICs9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxaIC8gKHBvc2l0aW9ucy5sZW5ndGggLyAzKTtcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVUb3VjaCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGhhbmRsZVRvdWNoKTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG5cbiAgICAgICAgICAgIG1vdXNlLnggPSAodG91Y2guY2xpZW50WCAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIDIgLSAxO1xuICAgICAgICAgICAgbW91c2UueSA9IC0odG91Y2guY2xpZW50WSAvIHdpbmRvdy5pbm5lckhlaWdodCkgKiAyICsgMTtcbiAgICAgICAgICAgIG1vdXNlLnogPSBnZXRBdmVyYWdlUGFydGljbGVaKCk7XG5cbiAgICAgICAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlLCBjYW1lcmEpO1xuXG4gICAgICAgICAgICBjb25zdCBpbnRlcnNlY3RQb2ludCA9IHJheWNhc3Rlci5yYXkuYXQoMS4zKTtcblxuICAgICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggKz0gKGludGVyc2VjdFBvaW50LnggKiBjYW1lcmFQYXJhbGxheEZhY3RvciAtIGNhbWVyYS5wb3NpdGlvbi54KSAqIDAuMDU7XG4gICAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueSArPSAoLWludGVyc2VjdFBvaW50LnkgKiBjYW1lcmFQYXJhbGxheEZhY3RvciAtIGNhbWVyYS5wb3NpdGlvbi55KSAqIDAuMDUgO1xuICAgICAgICAgICAgY2FtZXJhLmxvb2tBdChzY2VuZS5wb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ICs9ICgtaW50ZXJzZWN0UG9pbnQueSAqIGNhbWVyYVBhcmFsbGF4RmFjdG9yIC0gY2FtZXJhLnBvc2l0aW9uLnkpICogMC4wNSArIDMwOyAvLyBBZGp1c3QgdGhpcyB2YWx1ZSBhcyBuZWVkZWRcblxuICAgICAgICAvLyBBZGQgYSBuZXcgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBhdmVyYWdlIHotY29vcmRpbmF0ZSBvZiBhbGwgcGFydGljbGVzXG5cbiAgICB9XG4gICAgY29uc3Qgc2NhbGUgPSA0OyAvLyBBZGp1c3QgdGhpcyB2YWx1ZSBmb3IgeW91ciBkZXNpcmVkIHNjYWxlLiBFLmcuLCAwLjUgbWVhbnMgdGhlIGltYWdlIHdpbGwgYmUgNTAlIHNtYWxsZXJcblxuICAgIHRleHR1cmVMb2FkZXIubG9hZCgnY2lyY2xlLnBuZycsIChpbWFnZVRleHR1cmUpID0+IHtcbiAgICAgICAgY29uc3QgaW1nV2lkdGggPSBpbWFnZVRleHR1cmUuaW1hZ2Uud2lkdGggKiBzY2FsZTtcbiAgICAgICAgY29uc3QgaW1nSGVpZ2h0ID0gaW1hZ2VUZXh0dXJlLmltYWdlLmhlaWdodCAqIHNjYWxlO1xuXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBpbWdXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZ0hlaWdodDtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlVGV4dHVyZS5pbWFnZSwgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG5cbiAgICAgICAgY29uc3QgaW1nRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpLmRhdGE7XG4gICAgICAgIGNvbnN0IHJlc29sdXRpb25GYWN0b3IgPSAzO1xuXG4gICAgICAgIGNvbnN0IHBhcnRpY2xlVGV4dHVyZSA9IHRleHR1cmVMb2FkZXIubG9hZCgncGFydGljbGVzMi5wbmcnKTtcbiAgICAgICAgY29uc3QgcGFydGljbGVzR2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgY29uc3QgcGFydGljbGVWZXJ0aWNlcyA9IFtdO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZUNvbG9ycyA9IFtdO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBpbmNyZWFzZWRCcmlnaHRuZXNzID0gMi4yNTsgLy8gUGxhY2UgdGhpcyBiZWZvcmUgdGhlIGxvb3BcblxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGltZ0hlaWdodDsgeSArPSByZXNvbHV0aW9uRmFjdG9yKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGltZ1dpZHRoOyB4ICs9IHJlc29sdXRpb25GYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9ICh5ICogaW1nV2lkdGggKyB4KSAqIDQ7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGltZ0RhdGFbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBpbWdEYXRhW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGltZ0RhdGFbaW5kZXggKyAyXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSAwLjcxNTIgKiByICsgMC4yMTI2ICogZyArIDAuMDcyMiAqIGI7XG4gICAgICAgICAgICAgICAgaWYgKGJyaWdodG5lc3MgPiAxMjgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeFBvcyA9ICh4IC8gaW1nV2lkdGggLSAwLjUpICogMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeVBvcyA9ICh5IC8gaW1nSGVpZ2h0IC0gMC41KSAqIC0yO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZVZlcnRpY2VzLnB1c2goeFBvcywgeVBvcywgMCk7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUG9zaXRpb25zLnB1c2goeFBvcywgeVBvcywgMCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlQ29sb3JzLnB1c2goKHIgLyAyNTUpICogaW5jcmVhc2VkQnJpZ2h0bmVzcyAqIDAuOCwgKGcgLyAyNTUpICogaW5jcmVhc2VkQnJpZ2h0bmVzcywgKGIgLyAyNTUpICogaW5jcmVhc2VkQnJpZ2h0bmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnRpY2xlQ29sb3JzLnB1c2goMSwgMCwgMCk7IC8vIFNldCBSR0IgdmFsdWVzIHRvICgxLCAwLCAwKSBmb3IgcmVkXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRpY2xlc0dlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwYXJ0aWNsZVZlcnRpY2VzLCAzKSk7XG4gICAgICAgIHBhcnRpY2xlc0dlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwYXJ0aWNsZUNvbG9ycywgMykpO1xuXG4gICAgICAgIGNvbnN0IHBhcnRpY2xlc01hdGVyaWFsID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHtcbiAgICAgICAgICAgIHNpemU6IDAuMDIsXG4gICAgICAgICAgICBtYXA6IHBhcnRpY2xlVGV4dHVyZSxcbiAgICAgICAgICAgIHZlcnRleENvbG9yczogdHJ1ZSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgb3BhY2l0eTogMSwgLy8gQWRqdXN0IHRoaXMgdmFsdWVcblxuXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZXMgPSBuZXcgVEhSRUUuUG9pbnRzKHBhcnRpY2xlc0dlb21ldHJ5LCBwYXJ0aWNsZXNNYXRlcmlhbCk7XG4gICAgICAgIC8vc2NlbmUuYWRkKHBhcnRpY2xlcyk7XG5cblxuICAgICAgICBjb25zdCByYWRpdXMgPSAxOyAvLyBSZXBsYWNlIHdpdGggdGhlIGRlc2lyZWQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSAzMjsgLy8gUmVwbGFjZSB3aXRoIHRoZSBkZXNpcmVkIG51bWJlciBvZiBzZWdtZW50cyB0byBhcHByb3hpbWF0ZSB0aGUgY2lyY2xlXG5cbiAgICAgICAgY29uc3QgY2lyY2xlVGV4dHVyZSA9IHRleHR1cmVMb2FkZXIubG9hZCgnY2lyY2xlNC5wbmcnKTtcbiAgICAgICAgY29uc3QgY2lyY2xlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IGNpcmNsZVRleHR1cmUgfSk7XG4gICAgICAgIGNvbnN0IGNpcmNsZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUdlb21ldHJ5KHJhZGl1cywgc2VnbWVudHMpO1xuICAgICAgICBjb25zdCBjaXJjbGVNZXNoID0gbmV3IFRIUkVFLk1lc2goY2lyY2xlR2VvbWV0cnksIGNpcmNsZU1hdGVyaWFsKTtcbiAgICAgICAgY2lyY2xlTWVzaC5wb3NpdGlvbi5zZXQoMCwgMCwgLTIpO1xuICAgICAgICBjaXJjbGVNZXNoLnJvdGF0aW9uLnNldCgwLCAwLCAwKTtcbiAgICAgICAgLy9zY2VuZS5hZGQoY2lyY2xlTWVzaCk7XG5cbiAgICAgICAgLy8gVGhlbiwgaW4geW91ciBhbmltYXRlIGZ1bmN0aW9uOlxuICAgICAgICBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gcGFydGljbGVzR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpICogMC4wMDAxOyAgLy8gYWRqdXN0IHRoZSBtdWx0aXBsaWVyIHRvIGNvbnRyb2wgdGhlIHNwZWVkIG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIGNvbnRyb2xzLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGxldCBwYXJ0aWNsZVBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXSwgcG9zaXRpb25zW2kgKyAyXSk7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMob3JpZ2luYWxQb3NpdGlvbnNbaV0sIG9yaWdpbmFsUG9zaXRpb25zW2kgKyAxXSwgb3JpZ2luYWxQb3NpdGlvbnNbaSArIDJdKTtcblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcGFydGljbGUgYW5kIHRoZSBtb3VzZVxuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZVRvTW91c2UgPSBwYXJ0aWNsZVBvcy5kaXN0YW5jZVRvKG1vdXNlKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIG1vdXNlUmFkaXVzLCBtb3ZlIHRoZSBwYXJ0aWNsZSB0b3dhcmRzIHRoZSBtb3VzZVxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVRvTW91c2UgPCBtb3VzZVJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZVBvcy5sZXJwKG5ldyBUSFJFRS5WZWN0b3IzKG1vdXNlLngsIG1vdXNlLnksIHBhcnRpY2xlUG9zLnopLCBtb3VzZVN0cmVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIG1vdmUgdGhlIHBhcnRpY2xlIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlUG9zLmxlcnAob3JpZ2luYWxQb3MsIDAuMDUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgbm9pc2UgZnVuY3Rpb24gdG8gZ2V0IGEgc21vb3RoLCB2YXJ5aW5nIHZhbHVlIGZvciBlYWNoIHBhcnRpY2xlXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9pc2VWYWx1ZSA9IG5vaXNlM0RGdW5jdGlvbihwYXJ0aWNsZVBvcy54LCBwYXJ0aWNsZVBvcy55LCB0aW1lKTtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgbm9pc2UgdmFsdWUgdG8gYWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcGFydGljbGVcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZVBvcy56ICs9IG5vaXNlVmFsdWUgKiAwLjAxOyAgLy8gYWRqdXN0IHRoZSBtdWx0aXBsaWVyIHRvIGNvbnRyb2wgdGhlIGFtcGxpdHVkZSBvZiB0aGUgYW5pbWF0aW9uXG5cbiAgICAgICAgICAgICAgICBwb3NpdGlvbnNbaV0gPSBwYXJ0aWNsZVBvcy54O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tpICsgMV0gPSBwYXJ0aWNsZVBvcy55O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tpICsgMl0gPSBwYXJ0aWNsZVBvcy56O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0aWNsZXNHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9yZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICAgICAgICBjb21wb3Nlci5yZW5kZXIoKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW1hdGUoKTtcbiAgICB9KTtcblxuICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gMS4zODtcbiAgICBjYW1lcmEucG9zaXRpb24ueSArPSAxMDsgLy8gQWRqdXN0IHRoaXMgdmFsdWUgYXMgbmVlZGVkXG5cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgICBjYW1lcmEuYXNwZWN0ID0gbmV3V2lkdGggLyBuZXdIZWlnaHQ7XG4gICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgY29tcG9zZXIuc2V0U2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICB9KTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VvcmllbnRhdGlvbicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgYWxwaGEgPSBldmVudC5hbHBoYTtcbiAgICAgICAgdmFyIGJldGEgPSBldmVudC5iZXRhO1xuICAgICAgICB2YXIgZ2FtbWEgPSBldmVudC5nYW1tYTtcblxuICAgICAgICAvLyBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICAgICAgICB2YXIgYWxwaGFSYWQgPSBhbHBoYSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgdmFyIGJldGFSYWQgPSBiZXRhICogKE1hdGguUEkgLyAxODApO1xuICAgICAgICB2YXIgZ2FtbWFSYWQgPSBnYW1tYSAqIChNYXRoLlBJIC8gMTgwKTtcblxuICAgICAgICAvLyBBcHBseSByb3RhdGlvbiB0byB0aGUgY2FtZXJhXG4gICAgICAgIGNhbWVyYS5yb3RhdGlvbi5zZXQoYmV0YVJhZCwgYWxwaGFSYWQsIC1nYW1tYVJhZCk7XG4gICAgfSwgdHJ1ZSk7XG59Il0sIm5hbWVzIjpbIlRIUkVFIiwiRWZmZWN0Q29tcG9zZXIiLCJSZW5kZXJQYXNzIiwiVW5yZWFsQmxvb21QYXNzIiwiY3JlYXRlTm9pc2UzRCIsIkdMVEZMb2FkZXIiLCJPcmJpdENvbnRyb2xzIiwiaW5pdGlhbGl6ZVRocmVlSlMiLCJtb3VudFBvaW50Iiwibm9pc2UzREZ1bmN0aW9uIiwibW91c2VSYWRpdXMiLCJtb3VzZVN0cmVuZ3RoIiwic2NlbmUiLCJTY2VuZSIsImNhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwicmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwiYWxwaGEiLCJzZXRTaXplIiwic2V0Q2xlYXJDb2xvciIsImFwcGVuZENoaWxkIiwiZG9tRWxlbWVudCIsImNvbXBvc2VyIiwicmVuZGVyUGFzcyIsImFkZFBhc3MiLCJibG9vbU9wdGlvbnMiLCJzdHJlbmd0aCIsInJhZGl1cyIsInRocmVzaG9sZCIsImJsb29tUGFzcyIsIlZlY3RvcjIiLCJ0ZXh0dXJlTG9hZGVyIiwiVGV4dHVyZUxvYWRlciIsIm1vdXNlIiwicmF5Y2FzdGVyIiwiUmF5Y2FzdGVyIiwiY2FtZXJhUGFyYWxsYXhGYWN0b3IiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJ6IiwiZ2V0QXZlcmFnZVBhcnRpY2xlWiIsInNldEZyb21DYW1lcmEiLCJyYXkiLCJjb25zb2xlIiwiZXJyb3IiLCJpbnRlcnNlY3RQb2ludCIsIlZlY3RvcjMiLCJhdCIsInBvc2l0aW9uIiwibG9va0F0IiwiY29udHJvbHMiLCJlbmFibGVSb3RhdGUiLCJlbmFibGVQYW4iLCJlbmFibGVab29tIiwibWluUG9sYXJBbmdsZSIsIm1heFBvbGFyQW5nbGUiLCJNYXRoIiwiUEkiLCJwYXJ0aWNsZXNHZW9tZXRyeSIsImFtYmllbnRMaWdodCIsIkFtYmllbnRMaWdodCIsImFkZCIsImRpcmVjdGlvbmFsTGlnaHQiLCJEaXJlY3Rpb25hbExpZ2h0Iiwic2V0IiwibG9hZGVyIiwibG9hZCIsImdsdGYiLCJ1bmRlZmluZWQiLCJyb3RhdGlvbiIsImltYWdlVGV4dHVyZSIsInBvc2l0aW9ucyIsImF0dHJpYnV0ZXMiLCJhcnJheSIsInRvdGFsWiIsImkiLCJsZW5ndGgiLCJoYW5kbGVUb3VjaCIsInByZXZlbnREZWZhdWx0IiwidG91Y2hlcyIsInRvdWNoIiwic2NhbGUiLCJpbWdXaWR0aCIsImltYWdlIiwid2lkdGgiLCJpbWdIZWlnaHQiLCJoZWlnaHQiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsImltZ0RhdGEiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwicmVzb2x1dGlvbkZhY3RvciIsInBhcnRpY2xlVGV4dHVyZSIsIkJ1ZmZlckdlb21ldHJ5IiwicGFydGljbGVWZXJ0aWNlcyIsInBhcnRpY2xlQ29sb3JzIiwib3JpZ2luYWxQb3NpdGlvbnMiLCJpbmNyZWFzZWRCcmlnaHRuZXNzIiwiaW5kZXgiLCJyIiwiZyIsImIiLCJicmlnaHRuZXNzIiwieFBvcyIsInlQb3MiLCJwdXNoIiwic2V0QXR0cmlidXRlIiwiRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSIsInBhcnRpY2xlc01hdGVyaWFsIiwiUG9pbnRzTWF0ZXJpYWwiLCJzaXplIiwibWFwIiwidmVydGV4Q29sb3JzIiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5IiwicGFydGljbGVzIiwiUG9pbnRzIiwic2VnbWVudHMiLCJjaXJjbGVUZXh0dXJlIiwiY2lyY2xlTWF0ZXJpYWwiLCJNZXNoQmFzaWNNYXRlcmlhbCIsImNpcmNsZUdlb21ldHJ5IiwiQ2lyY2xlR2VvbWV0cnkiLCJjaXJjbGVNZXNoIiwiTWVzaCIsImFuaW1hdGUiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsInVwZGF0ZSIsInBhcnRpY2xlUG9zIiwib3JpZ2luYWxQb3MiLCJkaXN0YW5jZVRvTW91c2UiLCJkaXN0YW5jZVRvIiwibGVycCIsIm5vaXNlVmFsdWUiLCJuZWVkc1VwZGF0ZSIsInJlbmRlciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsImV2ZW50IiwiYmV0YSIsImdhbW1hIiwiYWxwaGFSYWQiLCJiZXRhUmFkIiwiZ2FtbWFSYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/app.js\n"));

/***/ })

});